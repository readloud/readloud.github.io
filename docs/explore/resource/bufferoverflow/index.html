<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="readloud">
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Buffer overflows - readloud.org</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Buffer overflows", url: "#_top", children: [
              {title: "Stack-based exploitation - Stack buffer overflow", url: "#stack-based-exploitation-stack-buffer-overflow" },
              {title: "Function gets", url: "#function-gets" },
              {title: "Vulnerable code", url: "#vulnerable-code" },
              {title: "#include \u0026lt;stdio.h\u0026gt; int main () { char username[8]; int allow = 0; printf external link(\u0026quot;Enter your username, please: \u0026quot;); gets(username); // user inputs \u0026quot;malicious\u0026quot; if (grantAccess(username)) { allow = 1; } if (allow != 0) { // has been overwritten by the overflow of the username. privilegedAction(); } return 0; }", url: "#include-stdioh-int-main-char-username8-int-allow-0-printf-external-linkenter-your-username-please-getsusername-user-inputs-malicious-if-grantaccessusername-allow-1-if-allow-0-has-been-overwritten-by-the-overflow-of-the-username-privilegedaction-return-0" },
              {title: "Mitigation", url: "#mitigation" },
              {title: "#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define LENGTH 8 int main () { char* username, *nlptr; int allow = 0; username = malloc(LENGTH * sizeof(*username)); if (!username) return EXIT_FAILURE; printf external link(\u0026quot;Enter your username, please: \u0026quot;); fgets(username,LENGTH, stdin); // fgets stops after LENGTH-1 characters or at a newline character, which ever comes first. // but it considers \\n a valid character, so you might want to remove it: nlptr = strchr(username, \u0026#39;\\n\u0026#39;); if (nlptr) *nlptr = \u0026#39;\\0\u0026#39;; if (grantAccess(username)) { allow = 1; } if (allow != 0) { priviledgedAction(); } free(username); return 0; }", url: "#include-stdioh-include-stdlibh-define-length-8-int-main-char-username-nlptr-int-allow-0-username-malloclength-sizeofusername-if-username-return-exit_failure-printf-external-linkenter-your-username-please-fgetsusernamelength-stdin-fgets-stops-after-length-1-characters-or-at-a-newline-character-which-ever-comes-first-but-it-considers-n-a-valid-character-so-you-might-want-to-remove-it-nlptr-strchrusername-n-if-nlptr-nlptr-0-if-grantaccessusername-allow-1-if-allow-0-priviledgedaction-freeusername-return-0" },
              {title: "Function strcpy", url: "#function-strcpy" },
              {title: "Vulnerable code", url: "#vulnerable-code_1" },
              {title: "char str1[10]; char str2[]=\u0026quot;abcdefghijklmn\u0026quot;; strcpy(str1,str2);", url: "#char-str110-char-str2abcdefghijklmn-strcpystr1str2" },
              {title: "Mitigation", url: "#mitigation_1" },
              {title: "Function sprintf", url: "#function-sprintf" },
          ]},
          {title: "Integer Overflow", url: "#integer-overflow", children: [
              {title: "What is an integer?", url: "#what-is-an-integer" },
              {title: "msfpayload windows/shell_bind_tcp R | msfencode -a x86 -b \u0026quot;\\x00\\x0d\u0026quot; -t -cReturn-to-libc attack", url: "#msfpayload-windowsshell_bind_tcp-r-msfencode-a-x86-b-x00x0d-t-creturn-to-libc-attack" },
              {title: "Example 1:", url: "#example-1" },
              {title: "Sources", url: "#sources" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="buffer-overflows">Buffer overflows</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Buffer_overflow">wikipedia</a></li>
</ul>
<p>In computer security, a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. It is called "shellcode" because it typically starts a command shell from which the attacker can control the compromised machine, but any piece of code that performs a similar task can be called shellcode. Because the function of a payload is not limited to merely spawning a shell, some have suggested that the name shellcode is insufficient.[1] However, attempts at replacing the term have not gained wide acceptance. </p>
<p>Buffer overflows can be triggered by inputs that are designed to execute code, or alter the way the program operates. This may result in erratic program behavior, including memory access errors, incorrect results, a crash, or a breach of system security. Thus, they are the basis of many software vulnerabilities and can be maliciously exploited.</p>
<p>Buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites memory in adjacent locations. This is a special case of the violation of memory safety.</p>
<p>The techniques to exploit a buffer overflow vulnerability vary by architecture, by operating system and by memory region. For example, exploitation on the heap (used for dynamically allocated memory), differs markedly from exploitation on the call stack.</p>
<h2 id="stack-based-exploitation-stack-buffer-overflow">Stack-based exploitation - Stack buffer overflow</h2>
<p>A technically inclined user may exploit stack-based buffer overflows to manipulate the program to their advantage in one of several ways:</p>
<p>by overwriting a local variable that is near the buffer in memory on the stack to change the behavior of the program - which may benefit the attacker.
by overwriting the return address in a stack frame. Once the function returns, execution will resume at the return address as specified by the attacker, usually a user-input filled buffer.
by overwriting a function pointer[1] or exception handler, which is subsequently executed
by overwriting a parameter of a different stack frame or a non-local address pointed to in the current stack context[2]</p>
<p>Programming languages commonly associated with buffer overflows include C and C++, which provide no built-in protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array. </p>
<p>Bounds checking can prevent buffer overflows.</p>
<p>[SOURCE CODE]</p>
<p>================
VULNERABLE CODE
================
<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>/* overflow.c - demuestra un desbordamiento de buffer */
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>#include &lt;stdio.h&gt;
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>#include &lt;string.h&gt;
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>int main(int argc, char *argv[])
</span><span id="__span-0-7"><a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>{
</span><span id="__span-0-8"><a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>  char buffer[10];
</span><span id="__span-0-9"><a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>  if (argc &lt; 2)
</span><span id="__span-0-10"><a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a>  {
</span><span id="__span-0-11"><a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a>    fprintf(stderr, &quot;MODO DE USO: %s string\n&quot;, argv[0]);
</span><span id="__span-0-12"><a id="__codelineno-0-12" name="__codelineno-0-12" href="#__codelineno-0-12"></a>    return 1;
</span><span id="__span-0-13"><a id="__codelineno-0-13" name="__codelineno-0-13" href="#__codelineno-0-13"></a>  }
</span><span id="__span-0-14"><a id="__codelineno-0-14" name="__codelineno-0-14" href="#__codelineno-0-14"></a>  strcpy(buffer, argv[1]);
</span><span id="__span-0-15"><a id="__codelineno-0-15" name="__codelineno-0-15" href="#__codelineno-0-15"></a>  return 0;
</span><span id="__span-0-16"><a id="__codelineno-0-16" name="__codelineno-0-16" href="#__codelineno-0-16"></a>}
</span></code></pre></div>
=============
SECURE CODE
=============
<div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>/* mejor.c - demuestra un m√©todo de resolver el problema */
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>#include &lt;stdio.h&gt;
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>#include &lt;string.h&gt;
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>int main(int argc, char *argv[])
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a>{
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>  char buffer[10];
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a>  if (argc &lt; 2)
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a>  {
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a>    fprintf(stderr, &quot;MODO DE USO: %s string\n&quot;, argv[0]);
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a>    return 1;
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a>  }
</span><span id="__span-1-14"><a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a>  strncpy(buffer, argv[1], sizeof(buffer));
</span><span id="__span-1-15"><a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a>  buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
</span><span id="__span-1-16"><a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a>  return 0;
</span><span id="__span-1-17"><a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a>}
</span></code></pre></div>
================
VULNERABLE CODE
================
<div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>#include &lt;stdio.h&gt;
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>#include &lt;string.h&gt;
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>int main( int argc, char *argv[] )
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>{
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>  // Buffer est√°tico en la pila.
</span><span id="__span-2-6"><a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a>  char buffer[1024];
</span><span id="__span-2-7"><a id="__codelineno-2-7" name="__codelineno-2-7" href="#__codelineno-2-7"></a>  if ( argc != 2 )
</span><span id="__span-2-8"><a id="__codelineno-2-8" name="__codelineno-2-8" href="#__codelineno-2-8"></a>  {
</span><span id="__span-2-9"><a id="__codelineno-2-9" name="__codelineno-2-9" href="#__codelineno-2-9"></a>    printf(&quot;Uso: %s argumento\n&quot;, argv[0] );
</span><span id="__span-2-10"><a id="__codelineno-2-10" name="__codelineno-2-10" href="#__codelineno-2-10"></a>    return( -1 );
</span><span id="__span-2-11"><a id="__codelineno-2-11" name="__codelineno-2-11" href="#__codelineno-2-11"></a>  }
</span><span id="__span-2-12"><a id="__codelineno-2-12" name="__codelineno-2-12" href="#__codelineno-2-12"></a>  // Copiado de cadenas sin control.
</span><span id="__span-2-13"><a id="__codelineno-2-13" name="__codelineno-2-13" href="#__codelineno-2-13"></a>  strcpy( buffer, argv[1]);
</span><span id="__span-2-14"><a id="__codelineno-2-14" name="__codelineno-2-14" href="#__codelineno-2-14"></a>  printf( &quot;Argumento copiado\n&quot; );
</span><span id="__span-2-15"><a id="__codelineno-2-15" name="__codelineno-2-15" href="#__codelineno-2-15"></a>  return(0);
</span><span id="__span-2-16"><a id="__codelineno-2-16" name="__codelineno-2-16" href="#__codelineno-2-16"></a>}
</span></code></pre></div></p>
<p>Bugs : 
            - A bug is a defect in the implementation
            - A flaw is a defect in the design</p>
<ul>
<li><a href="http://challenges.re/">challenges</a></li>
<li><a href="http://beginners.re/Control-Flow Integrity">Control-Flow Integrity</a></li>
<li><a href="http://research.microsoft.com/pubs/64250/ccs05.pdf">research</a></li>
<li><a href="https://en.wikipedia.org/wiki/Control_flowgets">Control_flowgets</a></li>
</ul>
<p>The stdio <code>gets()</code> function does not check for buffer length and always results in a vulnerability.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Integer_overflow">Integer_overflow</a></li>
</ul>
<p>integer overflow occurs when an arithmetic operation attempts to create a numeric value that is too large to be represented within the available storage space</p>
<ul>
<li><a href="http://www.mjmwired.net/kernel/Documentation/sysctl/kernel.txt">kernel</a></li>
</ul>
<p><code>msfpayload windows/</code></p>
<p><code>shell_bind_tcp R | msfencode -a x86 -b "\x00\x0d" -t -cpsexecReturn-to-libc attack</code></p>
<p>A <code>return-to-libc</code> attack is a computer security attack usually starting with a buffer overflow in which a subroutine return address on a call stack is replaced by an address of a subroutine that is already present in the process‚Äô executable memory, bypassing the NX bit feature (if present) and ridding the attacker of the need to inject their own code.ROP (Return Oriented Proragmming ) Attack</p>
<p>This type of attack was introduced by Hovav Shacham of Stanford University in his paper ‚ÄúThe Geometry of Innocent Flesh on the Bone:Return-into-libc without Function Calls (on the x86).‚Äù </p>
<p>That means this type of attack is able to perform arbitrary computation without the necessary use of library functions by reusing code chunks which he calls GADGETS.</p>
<h3 id="rop-attacks-loading-and-storing-data">ROP Attacks (Loading and Storing Data)</h3>
<p>There are certain gadgets that allows us to store and load data from one place to another. Modes of transfer include:</p>
<ul>
<li>1: register to register</li>
<li>2: register to memory</li>
<li>3: memory to register<div class="language-text highlight"><pre><span></span><code>* [return-oriented-programming-rop-attacks](http://resources.infosecinstitute.com/return-oriented-programming-rop-attacks/)
* [shell-storm](http://shell-storm.org/)
* [Kennedy Sanchez](ksanchez@cldeveloper.com)
</code></pre></div>
</li>
</ul>
<p>Shellcode is commonly written in machine code.</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>; hello world in 64-bit assembly for Linux
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>        global  _start
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>        section .text
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>_start:
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a>        ; write is system call 1
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>        mov     rax, 1                  ; system call 1 is write
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a>        mov     rdi, 1                  ; file handle 1 is stdout
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a>        mov     rsi, message            ; address of string to output
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a>        mov     rdx, len                 ; number of bytes
</span><span id="__span-3-10"><a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a>        syscall                         ; invoke syscall
</span><span id="__span-3-11"><a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a>
</span><span id="__span-3-12"><a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a>        ; exit(0)
</span><span id="__span-3-13"><a id="__codelineno-3-13" name="__codelineno-3-13" href="#__codelineno-3-13"></a>        mov     eax, 60                 ; system call 60 is exit
</span><span id="__span-3-14"><a id="__codelineno-3-14" name="__codelineno-3-14" href="#__codelineno-3-14"></a>        xor     rdi, rdi                ; exit code 0
</span><span id="__span-3-15"><a id="__codelineno-3-15" name="__codelineno-3-15" href="#__codelineno-3-15"></a>        syscall                         ; invoke operating system to exit
</span><span id="__span-3-16"><a id="__codelineno-3-16" name="__codelineno-3-16" href="#__codelineno-3-16"></a>message:
</span><span id="__span-3-17"><a id="__codelineno-3-17" name="__codelineno-3-17" href="#__codelineno-3-17"></a>        db      &quot;Hello, Reverser!&quot;, 10  ; 10 is a newline      
</span><span id="__span-3-18"><a id="__codelineno-3-18" name="__codelineno-3-18" href="#__codelineno-3-18"></a>len:    equ     $ - message
</span><span id="__span-3-19"><a id="__codelineno-3-19" name="__codelineno-3-19" href="#__codelineno-3-19"></a>; hello world in 32-bit assembly for Linux
</span><span id="__span-3-20"><a id="__codelineno-3-20" name="__codelineno-3-20" href="#__codelineno-3-20"></a>        global  _start
</span><span id="__span-3-21"><a id="__codelineno-3-21" name="__codelineno-3-21" href="#__codelineno-3-21"></a>        section .text
</span><span id="__span-3-22"><a id="__codelineno-3-22" name="__codelineno-3-22" href="#__codelineno-3-22"></a>_start:
</span><span id="__span-3-23"><a id="__codelineno-3-23" name="__codelineno-3-23" href="#__codelineno-3-23"></a>        ; write is system call 4
</span><span id="__span-3-24"><a id="__codelineno-3-24" name="__codelineno-3-24" href="#__codelineno-3-24"></a>        mov     eax, 4                  ; system call 4 is write
</span><span id="__span-3-25"><a id="__codelineno-3-25" name="__codelineno-3-25" href="#__codelineno-3-25"></a>        mov     ebx, 1                  ; file handle 1 is stdout
</span><span id="__span-3-26"><a id="__codelineno-3-26" name="__codelineno-3-26" href="#__codelineno-3-26"></a>        mov     ecx, message            ; address of string to output
</span><span id="__span-3-27"><a id="__codelineno-3-27" name="__codelineno-3-27" href="#__codelineno-3-27"></a>        mov     edx, len                ; number of bytes
</span><span id="__span-3-28"><a id="__codelineno-3-28" name="__codelineno-3-28" href="#__codelineno-3-28"></a>        int 0x80                    ; invoke syscall
</span><span id="__span-3-29"><a id="__codelineno-3-29" name="__codelineno-3-29" href="#__codelineno-3-29"></a>
</span><span id="__span-3-30"><a id="__codelineno-3-30" name="__codelineno-3-30" href="#__codelineno-3-30"></a>        ; exit(0)
</span><span id="__span-3-31"><a id="__codelineno-3-31" name="__codelineno-3-31" href="#__codelineno-3-31"></a>        mov     eax, 1                 ; system call 1 is exit
</span><span id="__span-3-32"><a id="__codelineno-3-32" name="__codelineno-3-32" href="#__codelineno-3-32"></a>        xor     ebx, ebx                ; exit code 0
</span><span id="__span-3-33"><a id="__codelineno-3-33" name="__codelineno-3-33" href="#__codelineno-3-33"></a>        int 0x80                         ; invoke operating system to exit
</span><span id="__span-3-34"><a id="__codelineno-3-34" name="__codelineno-3-34" href="#__codelineno-3-34"></a>message:
</span><span id="__span-3-35"><a id="__codelineno-3-35" name="__codelineno-3-35" href="#__codelineno-3-35"></a>        db      &quot;Hello, Reverser!&quot;, 10  ; 10 is a newline      
</span><span id="__span-3-36"><a id="__codelineno-3-36" name="__codelineno-3-36" href="#__codelineno-3-36"></a>len:    equ     $ - message
</span></code></pre></div>
<p>Introductory Intel x86: Architecture, Assembly, Applications, &amp; Alliteration</p>
<div class="language-text highlight"><pre><span></span><code>* [IntroX86](   - http://opensecuritytraining.info/IntroX86.html)
* [Exploit tutorial: Buffer Overflow](https://www.reddit.com/r/hacking/comments/1wy610/exploit_tutorial_buffer_overflow/)
* [Exploit writing tutorial part 1 : Stack Based Overflows](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/)
* [Introduction To Software Exploits](http://opensecuritytraining.info/Exploits1.html)
* [Protostar Exploits Exercises](https://exploit-exercises.com/protostar/)
* [security.web](https://security.web.cern.ch/security/recommendations/en/codetools/c.shtml) 
* [pubs.opengroup.org](http://pubs.opengroup.org/onlinepubs/009695399/functions/printf.html)
</code></pre></div>
<p>[Wargames]</p>
<ul>
<li><a href="http://overthewire.org/wargames/narnia/">wargames</a></li>
<li><a href="http://challenges.re/">challenges.re</a></li>
<li><a href="http://beginners.re/"> beginners.re</a></li>
</ul>
<p>[Vulnerable Server] </p>
<ul>
<li><a href="http://www.thegreycorner.com/2010/12/introducing-vulnserver.html">Vulnserver</a></li>
<li><a href="http://resources.infosecinstitute.com/fuzzing-vulnserver-discovering-vulnerable-commands-part-1/">Fuzzing Vulnserver</a></li>
</ul>
<h3 id="common-vulnerabilities-guide-for-c-programmers">Common vulnerabilities guide for C programmers</h3>
<p>Most vulnerabilities in C are related to buffer overflows external link and string manipulation. In most cases, this would result in a segmentation fault, but specially crafted malicious input values, adapted to the architecture and environment could yield to arbitrary code execution. </p>
<hr />
<h2 id="function-gets">Function gets</h2>
<p><code>The stdio gets() function does not check for buffer length and always results in a vulnerability.</code></p>
<hr />
<h2 id="vulnerable-code">Vulnerable code</h2>
<h2 id="include-stdioh-int-main-char-username8-int-allow-0-printf-external-linkenter-your-username-please-getsusername-user-inputs-malicious-if-grantaccessusername-allow-1-if-allow-0-has-been-overwritten-by-the-overflow-of-the-username-privilegedaction-return-0"><div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>#include &lt;stdio.h&gt;
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>int main () {
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>    char username[8];
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>    int allow = 0;
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>    printf external link(&quot;Enter your username, please: &quot;);
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>    gets(username); // user inputs &quot;malicious&quot;
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>    if (grantAccess(username)) {
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a>        allow = 1;
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a>    }
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a>    if (allow != 0) { // has been overwritten by the overflow of the username.
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>        privilegedAction();
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>    }
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>    return 0;
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a>}
</span></code></pre></div></h2>
<h2 id="mitigation">Mitigation</h2>
<h2 id="include-stdioh-include-stdlibh-define-length-8-int-main-char-username-nlptr-int-allow-0-username-malloclength-sizeofusername-if-username-return-exit_failure-printf-external-linkenter-your-username-please-fgetsusernamelength-stdin-fgets-stops-after-length-1-characters-or-at-a-newline-character-which-ever-comes-first-but-it-considers-n-a-valid-character-so-you-might-want-to-remove-it-nlptr-strchrusername-n-if-nlptr-nlptr-0-if-grantaccessusername-allow-1-if-allow-0-priviledgedaction-freeusername-return-0"><div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>#include &lt;stdio.h&gt;
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>#include &lt;stdlib.h&gt;
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>#define LENGTH 8
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>int main () {
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>    char* username, *nlptr;
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>    int allow = 0;
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a>    username = malloc(LENGTH * sizeof(*username));
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a>    if (!username)
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a>        return EXIT_FAILURE;
</span><span id="__span-5-11"><a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a>    printf external link(&quot;Enter your username, please: &quot;);
</span><span id="__span-5-12"><a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a>    fgets(username,LENGTH, stdin);
</span><span id="__span-5-13"><a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a>    // fgets stops after LENGTH-1 characters or at a newline character, which ever comes first.
</span><span id="__span-5-14"><a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a>    // but it considers \n a valid character, so you might want to remove it:
</span><span id="__span-5-15"><a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a>    nlptr = strchr(username, &#39;\n&#39;);
</span><span id="__span-5-16"><a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a>    if (nlptr) *nlptr = &#39;\0&#39;;
</span><span id="__span-5-17"><a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a>
</span><span id="__span-5-18"><a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a>    if (grantAccess(username)) {
</span><span id="__span-5-19"><a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a>        allow = 1;
</span><span id="__span-5-20"><a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a>    }
</span><span id="__span-5-21"><a id="__codelineno-5-21" name="__codelineno-5-21" href="#__codelineno-5-21"></a>    if (allow != 0) {
</span><span id="__span-5-22"><a id="__codelineno-5-22" name="__codelineno-5-22" href="#__codelineno-5-22"></a>        priviledgedAction();
</span><span id="__span-5-23"><a id="__codelineno-5-23" name="__codelineno-5-23" href="#__codelineno-5-23"></a>    }
</span><span id="__span-5-24"><a id="__codelineno-5-24" name="__codelineno-5-24" href="#__codelineno-5-24"></a>
</span><span id="__span-5-25"><a id="__codelineno-5-25" name="__codelineno-5-25" href="#__codelineno-5-25"></a>    free(username);
</span><span id="__span-5-26"><a id="__codelineno-5-26" name="__codelineno-5-26" href="#__codelineno-5-26"></a>
</span><span id="__span-5-27"><a id="__codelineno-5-27" name="__codelineno-5-27" href="#__codelineno-5-27"></a>    return 0;
</span><span id="__span-5-28"><a id="__codelineno-5-28" name="__codelineno-5-28" href="#__codelineno-5-28"></a>}
</span></code></pre></div></h2>
<h2 id="function-strcpy">Function strcpy</h2>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>strcpy
</span></code></pre></div>
The strcpy built-in function does not check buffer lengths and may very well overwrite memory zone contiguous to the intended destination. In fact, the whole family of functions is similarly vulnerable: strcpy, strcat and strcmp.</p>
<hr />
<h2 id="vulnerable-code_1">Vulnerable code</h2>
<h2 id="char-str110-char-str2abcdefghijklmn-strcpystr1str2"><div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>char str1[10];
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>char str2[]=&quot;abcdefghijklmn&quot;;
</span><span id="__span-7-3"><a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>strcpy(str1,str2);
</span></code></pre></div></h2>
<h2 id="mitigation_1">Mitigation</h2>
<p>The best way to mitigate this issue is to use strlcpy if it is readily available (which is only the case on BSD systems). However, it is very simple to define it yourself, as shown below:</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>#include &lt;stdio.h&gt;
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a>
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a>#ifndef strlcpy
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a>#define strlcpy(dst,src,sz) snprintf((dst), (sz), &quot;%s&quot;, (src))
</span><span id="__span-8-5"><a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a>#endif
</span><span id="__span-8-6"><a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a>
</span><span id="__span-8-7"><a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a>enum { BUFFER_SIZE = 10 };
</span><span id="__span-8-8"><a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a>
</span><span id="__span-8-9"><a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>int main() {
</span><span id="__span-8-10"><a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a>    char dst[BUFFER_SIZE];
</span><span id="__span-8-11"><a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a>    char src[] = &quot;abcdefghijk&quot;;
</span><span id="__span-8-12"><a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a>
</span><span id="__span-8-13"><a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a>    int buffer_length = strlcpy(dst, src, BUFFER_SIZE);
</span><span id="__span-8-14"><a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a>
</span><span id="__span-8-15"><a id="__codelineno-8-15" name="__codelineno-8-15" href="#__codelineno-8-15"></a>    if (buffer_length &gt;= BUFFER_SIZE) {
</span><span id="__span-8-16"><a id="__codelineno-8-16" name="__codelineno-8-16" href="#__codelineno-8-16"></a>        printf external link(&quot;String too long: %d (%d expected)\n&quot;,
</span><span id="__span-8-17"><a id="__codelineno-8-17" name="__codelineno-8-17" href="#__codelineno-8-17"></a>                buffer_length, BUFFER_SIZE-1);
</span><span id="__span-8-18"><a id="__codelineno-8-18" name="__codelineno-8-18" href="#__codelineno-8-18"></a>    }
</span><span id="__span-8-19"><a id="__codelineno-8-19" name="__codelineno-8-19" href="#__codelineno-8-19"></a>
</span><span id="__span-8-20"><a id="__codelineno-8-20" name="__codelineno-8-20" href="#__codelineno-8-20"></a>    printf external link(&quot;String copied: %s\n&quot;, dst);
</span><span id="__span-8-21"><a id="__codelineno-8-21" name="__codelineno-8-21" href="#__codelineno-8-21"></a>
</span><span id="__span-8-22"><a id="__codelineno-8-22" name="__codelineno-8-22" href="#__codelineno-8-22"></a>    return 0;
</span><span id="__span-8-23"><a id="__codelineno-8-23" name="__codelineno-8-23" href="#__codelineno-8-23"></a>}
</span></code></pre></div>
Another and may be slightly less convenient way is to use strncpy, which prevents buffer overflows, but does not guarantee </p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>`\0&#39;-termination`.
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>enum { BUFFER_SIZE = 10 };
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>char str1[BUFFER_SIZE];
</span><span id="__span-9-5"><a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a>char str2[]=&quot;abcdefghijklmn&quot;;
</span><span id="__span-9-6"><a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a>
</span><span id="__span-9-7"><a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a>strncpy(str1,str2, BUFFER_SIZE); /* limit number of characters to be copied */
</span><span id="__span-9-8"><a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a>// We need to set the limit to BUFFER_SIZE, so that all characters in the buffer
</span><span id="__span-9-9"><a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a>// are set to &#39;\0&#39;. If the source buffer is longer than BUFFER_SIZE, all the &#39;\0&#39;
</span><span id="__span-9-10"><a id="__codelineno-9-10" name="__codelineno-9-10" href="#__codelineno-9-10"></a>// characters will be overwritten and the copy will be truncated.
</span><span id="__span-9-11"><a id="__codelineno-9-11" name="__codelineno-9-11" href="#__codelineno-9-11"></a>
</span><span id="__span-9-12"><a id="__codelineno-9-12" name="__codelineno-9-12" href="#__codelineno-9-12"></a>if (str1[BUFFER_SIZE-1] != &#39;\0&#39;) {
</span><span id="__span-9-13"><a id="__codelineno-9-13" name="__codelineno-9-13" href="#__codelineno-9-13"></a>    /* buffer was truncated, handle error? */
</span><span id="__span-9-14"><a id="__codelineno-9-14" name="__codelineno-9-14" href="#__codelineno-9-14"></a>}
</span></code></pre></div>
For the other functions in the family, the <em>n</em> variants exist as well: strncpm and strncat</p>
<hr />
<h2 id="function-sprintf">Function sprintf</h2>
<p><code>sprintf</code></p>
<p>Just as the previous functions, sprintf does not check the buffer boundaries and is vulnerable to overflows.</p>
<h1 id="integer-overflow">Integer Overflow</h1>
<hr />
<h2 id="what-is-an-integer">What is an integer?</h2>
<p>An integer, in the context of computing, is a variable capable of representing a real number with no fractional part.  Integers are typically the same size as a pointer on the system they are compiled Consequences.</p>
<p>Integers, like all variables are just regions of memory.</p>
<p>As well as binary and decimal, hexadecimal (base sixteen) is often used in computing as it is very easy to convert between binary and hexadecimal.</p>
<p>An integer overflow condition exists when an integer, which has not been properly sanity checked, is used in the determination of an offset or size for memory allocation, copying, concatenation, or similarly. If the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value.</p>
<p>Availability: Integer overflows generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high.</p>
<p>Integrity: If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the integer overflow has resulted in a buffer overflow condition, data corruption will most likely take place.</p>
<p>Access control (instruction processing): Integer overflows can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy.</p>
<h2 id="msfpayload-windowsshell_bind_tcp-r-msfencode-a-x86-b-x00x0d-t-creturn-to-libc-attack"><div class="language-text highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>msfpayload windows/shell_bind_tcp R | msfencode -a x86 -b &quot;\x00\x0d&quot; -t -cReturn-to-libc attack
</span></code></pre></div></h2>
<h2 id="example-1">Example 1:</h2>
<div class="language-text highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>    /* width1.c - exploiting a trivial widthness bug */
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a>    #include &lt;stdio.h&gt;
</span><span id="__span-11-3"><a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a>    #include &lt;string.h&gt;
</span><span id="__span-11-4"><a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a>
</span><span id="__span-11-5"><a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a>    int main(int argc, char *argv[]){
</span><span id="__span-11-6"><a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a>            unsigned short s;
</span><span id="__span-11-7"><a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a>            int i;
</span><span id="__span-11-8"><a id="__codelineno-11-8" name="__codelineno-11-8" href="#__codelineno-11-8"></a>            char buf[80];
</span><span id="__span-11-9"><a id="__codelineno-11-9" name="__codelineno-11-9" href="#__codelineno-11-9"></a>
</span><span id="__span-11-10"><a id="__codelineno-11-10" name="__codelineno-11-10" href="#__codelineno-11-10"></a>            if(argc &lt; 3){
</span><span id="__span-11-11"><a id="__codelineno-11-11" name="__codelineno-11-11" href="#__codelineno-11-11"></a>                    return -1;
</span><span id="__span-11-12"><a id="__codelineno-11-12" name="__codelineno-11-12" href="#__codelineno-11-12"></a>            }
</span><span id="__span-11-13"><a id="__codelineno-11-13" name="__codelineno-11-13" href="#__codelineno-11-13"></a>
</span><span id="__span-11-14"><a id="__codelineno-11-14" name="__codelineno-11-14" href="#__codelineno-11-14"></a>            i = atoi(argv[1]);
</span><span id="__span-11-15"><a id="__codelineno-11-15" name="__codelineno-11-15" href="#__codelineno-11-15"></a>            s = i;
</span><span id="__span-11-16"><a id="__codelineno-11-16" name="__codelineno-11-16" href="#__codelineno-11-16"></a>
</span><span id="__span-11-17"><a id="__codelineno-11-17" name="__codelineno-11-17" href="#__codelineno-11-17"></a>            if(s &gt;= 80){            /* [w1] */
</span><span id="__span-11-18"><a id="__codelineno-11-18" name="__codelineno-11-18" href="#__codelineno-11-18"></a>                    printf(&quot;Oh no you don&#39;t!\n&quot;);
</span><span id="__span-11-19"><a id="__codelineno-11-19" name="__codelineno-11-19" href="#__codelineno-11-19"></a>                    return -1;
</span><span id="__span-11-20"><a id="__codelineno-11-20" name="__codelineno-11-20" href="#__codelineno-11-20"></a>            }
</span><span id="__span-11-21"><a id="__codelineno-11-21" name="__codelineno-11-21" href="#__codelineno-11-21"></a>
</span><span id="__span-11-22"><a id="__codelineno-11-22" name="__codelineno-11-22" href="#__codelineno-11-22"></a>            printf(&quot;s = %d\n&quot;, s);
</span><span id="__span-11-23"><a id="__codelineno-11-23" name="__codelineno-11-23" href="#__codelineno-11-23"></a>
</span><span id="__span-11-24"><a id="__codelineno-11-24" name="__codelineno-11-24" href="#__codelineno-11-24"></a>            memcpy(buf, argv[2], i);
</span><span id="__span-11-25"><a id="__codelineno-11-25" name="__codelineno-11-25" href="#__codelineno-11-25"></a>            buf[i] = &#39;\0&#39;;
</span><span id="__span-11-26"><a id="__codelineno-11-26" name="__codelineno-11-26" href="#__codelineno-11-26"></a>            printf(&quot;%s\n&quot;, buf);
</span><span id="__span-11-27"><a id="__codelineno-11-27" name="__codelineno-11-27" href="#__codelineno-11-27"></a>
</span><span id="__span-11-28"><a id="__codelineno-11-28" name="__codelineno-11-28" href="#__codelineno-11-28"></a>            return 0;
</span><span id="__span-11-29"><a id="__codelineno-11-29" name="__codelineno-11-29" href="#__codelineno-11-29"></a>    }
</span></code></pre></div>
<hr />
<h2 id="sources">Sources</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Integer_overflow">wikipedia.org</a></li>
<li><a href="https://www.owasp.org/index.php/Integer_overflow">owasp.org</a></li>
<li><a href="https://www.cs.utah.edu/~regehr/papers/overflow12.pdf">cs.utah.edu</a></li>
<li><a href="http://phrack.org/issues/60/10.html">phrack.org</a></li>
</ul>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
      <p>
        <a href="https://github.com/readloud/readloud.github.io/releases/tag/themes/edit/master/docs/explore/resource/bufferoverflow.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/noraj/mkdocs-windmill-dark">Windmill Dark</a> theme by Alexandre ZANNI (noraj).</p>
<p>        ‚ö†Ô∏è The quieter you become, the more you are able to hear ü•∑</p>
</footer>

</body>
</html>